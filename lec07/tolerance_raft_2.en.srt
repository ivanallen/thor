1
00:00:01,000 --> 00:00:07,070
假设有三台像这样带有日志的服务
let's imagine three servers with logs

2
00:00:07,070 --> 00:00:13,400
假设有三台像这样的带有日志的服务
that looked like this where the numbers

3
00:00:13,400 --> 00:00:15,320
我正在写的数字是
I'm writing are the term numbers of the

4
00:00:15,320 --> 00:00:17,060
日志条目中命令的任期编号
command that's in that log entry

5
00:00:17,060 --> 00:00:18,500
所以我们不关心真正的命令是什么
so we don't really care what the actual commands are

6
00:00:18,500 --> 00:00:29,779
然后这里有一些日志插槽
then I got a number of the log slots

7
00:00:29,779 --> 00:00:35,290
然后让我们假设
and so let's imagine that the

8
00:00:35,290 --> 00:00:38,840
大概下一个任期是任期#6
presumably the the next term is term six

9
00:00:38,840 --> 00:00:40,820
尽管你实际无法根据黑板上的证据看出这一点
although you can't actually tell that

10
00:00:40,820 --> 00:00:42,500
尽管你实际无法根据黑板上的证据看出这一点
from looking the evidence on the board

11
00:00:42,500 --> 00:00:44,770
但是它至少是#6或更大
but it must be at least six or greater

12
00:00:44,770 --> 00:00:47,480
服务 S3 在任期#6
let's imagine that server S3 is chosen

13
00:00:47,480 --> 00:00:52,579
被选作领导者
as the leader for term six and at some

14
00:00:52,579 --> 00:00:56,120
在某个时刻 新的领导者S3
point S3 the new leader is going to want

15
00:00:56,120 --> 00:00:58,309
想发送新的日志条目
to send out a new log entry so let's

16
00:00:58,309 --> 00:01:00,110
假设它想发送任期#6的第一个日志条目
suppose it wants to send out its first

17
00:01:00,110 --> 00:01:02,989
假设它想发送任期#6的第一个日志条目
log entry for term six so we're

18
00:01:02,989 --> 00:01:04,459
我们考虑领导者即将发送的AppendEntries RPC请求
thinking about the AppendEntries RPCs

19
00:01:04,459 --> 00:01:06,200
我们考虑领导者即将发送的AppendEntries RPC请求
that the leader is going to send out

20
00:01:06,200 --> 00:01:11,299
来传输任期#6的第一个日志条目
to carry the first log entry for term six

21
00:01:11,299 --> 00:01:13,899
所以它应该在插槽#13下面
so it should be under slot thirteen

22
00:01:13,899 --> 00:01:16,459
图2的规则陈述了
the rules in Figure two say that an

23
00:01:16,459 --> 00:01:18,920
AppendEntries RPC请求的步骤2
AppendEntries RPC actually at step 2 

24
00:01:18,920 --> 00:01:22,099
以及客户端发给领导者的命令
as well as the command that the client sent

25
00:01:22,099 --> 00:01:23,119
我们想将它们复制到
in to the leader that we want to

26
00:01:23,119 --> 00:01:25,039
所有跟随者们的日志上
replicate on the logs of all the followers

27
00:01:25,039 --> 00:01:28,130
这个AppendEntries RPC
There's this AppendEntries RPC

28
00:01:28,130 --> 00:01:33,279
也包含了previousLogIndex字段
also contains this previousLogIndex field

29
00:01:33,279 --> 00:01:39,469
和previousLogTerm字段
and a previousLogTerm field

30
00:01:39,469 --> 00:01:44,270
在我们发送这个条目的AppendEntries时
and when we're sending out an AppendEntries

31
00:01:44,270 --> 00:01:46,429
在我们发送这个条目的AppendEntries时
for where this is the first entry

32
00:01:46,429 --> 00:01:48,859
领导者应该附加关于前一个插槽的信息
The leader's supposed to put

33
00:01:48,859 --> 00:01:51,380
领导者应该附加关于前一个插槽的信息
information about the previous slot the

34
00:01:51,380 --> 00:01:54,679
这个插槽在新的发送条目前面
slot before the new information sending

35
00:01:54,679 --> 00:01:57,169
所以在这种情况下 前一个条目的
out so in this case the log index

36
00:01:57,169 --> 00:02:02,029
日志索引previousLogIndex是12
of the previous entry is 12 

37
00:02:02,029 --> 00:02:06,709
其在领导者日志中的任期previousLogTerm是5
and the term of the command in the leader's log

38
00:02:06,709 --> 00:02:10,758
其在领导者日志中的任期previousLogTerm是5
for the previous entry is 5 so sends out this

39
00:02:10,758 --> 00:02:13,400
所以发送这些信息给跟随者们
information to the followers

40
00:02:13,400 --> 00:02:16,409
跟随者们在接受一个AppendEntries前
and the followers before they accept an

41
00:02:16,409 --> 00:02:18,959
应该检查……
AppendEntries are supposed to check you

42
00:02:18,959 --> 00:02:19,890
跟随者们知道他们接受到
know they know they've received an

43
00:02:19,890 --> 00:02:23,909
一个带有若干日志条目的AppendEntries
AppendEntries that for some log entries

44
00:02:23,909 --> 00:02:26,849
是从这里开始的
that start here and the first thing they

45
00:02:26,849 --> 00:02:29,310
首先他们要检查……
do is check that there are previous

46
00:02:29,310 --> 00:02:30,930
收到消息的跟随者们检查
The receiving followers check that their

47
00:02:30,930 --> 00:02:34,200
他们前一个日志条目是否匹配
previous log entry matches the previous

48
00:02:34,200 --> 00:02:36,120
领导者发来的关于前一条的信息
information that follow that the leader sent out

49
00:02:36,120 --> 00:02:38,310
所以对于服务#2 它显然是不匹配的
so for the server 2 of course it doesn't match

50
00:02:38,310 --> 00:02:42,360
服务#2在这里已经有一个条目了
The server 2 has a entry here

51
00:02:42,360 --> 00:02:43,950
但是它来自任期#4
all right but it's an entry from

52
00:02:43,950 --> 00:02:46,799
而不是任期#5
term 4 not from turn 5 and so the

53
00:02:46,799 --> 00:02:49,349
所以服务#2将拒绝这个AppendEntries
server two's going to reject this AppendEntries

54
00:02:49,349 --> 00:02:51,060
并回复false给领导者
and send a false reply back leader

55
00:02:51,060 --> 00:02:54,690
服务#1在这里还没有任何条目
and server one doesn't even

56
00:02:54,690 --> 00:02:56,700
所以服务#1也将
have anything here so server one's gonna

57
00:02:56,700 --> 00:03:00,000
拒绝领导者的这个AppendEntries
also reject the AppendEntries in the

58
00:03:00,000 --> 00:03:03,480
到目前为止很好
leader and so so far so good right the

59
00:03:03,480 --> 00:03:05,819
糟糕的事情已经
terrible thing that that has been

60
00:03:05,819 --> 00:03:08,220
在这里被避免
averted at this point is you know

61
00:03:08,220 --> 00:03:09,989
我们完全不想看到的坏事情是
the bad thing we absolutely don't want to

62
00:03:09,989 --> 00:03:12,030
服务把新的日志条目添加到这里
see is that server to actually stuck the

63
00:03:12,030 --> 00:03:15,209
服务把新的日志条目添加到这里
new log entry in here which would break

64
00:03:15,209 --> 00:03:20,280
这会打破图中方案所依赖的
sort of inductive proofs essentially

65
00:03:20,280 --> 00:03:24,599
归纳证明的顺序性
that the figure to scheme relies on and

66
00:03:24,599 --> 00:03:27,359
且会隐藏服务#2实际上
hide the fact that server 2 actually

67
00:03:27,359 --> 00:03:28,799
有一条不同的日志
had a different log so instead of

68
00:03:28,799 --> 00:03:30,299
所以服务#2没有接受这个日志条目
accepting log entry 

69
00:03:30,299 --> 00:03:33,440
而是拒绝了这个RPC请求
server 2 rejects this RPC

70
00:03:33,440 --> 00:03:36,150
所以领导者看到了两个拒绝
the leader sees is two rejections and

71
00:03:36,150 --> 00:03:38,329
领导者为每个跟随者维护了nextIndex
leader is maintaining this nextIndex field one for each

72
00:03:38,329 --> 00:03:47,199
所以它有一个服务#2的nextIndex
follower so it has a nextIndex for server 2

73
00:03:47,199 --> 00:03:53,629
以及服务#1的nextIndex
and the leader has a nextIndex for server 1

74
00:03:53,629 --> 00:03:54,660
如果……
presumably if the

75
00:03:54,660 --> 00:03:56,129
在这之前先说明
should have said this before If the

76
00:03:56,129 --> 00:03:58,430
如果服务在这里发送
server sending out information

77
00:03:58,430 --> 00:04:01,889
有关插槽#13的信息 这意味着
about slot 13 here That must mean that

78
00:04:01,889 --> 00:04:03,870
领导者对于这两个其他服务的nextIndex
the server's nextIndex is for both of

79
00:04:03,870 --> 00:04:09,090
从13开始
these other servers this started out as 13

80
00:04:09,090 --> 00:04:11,099
这种情况发生在
and that would be the case at

81
00:04:11,099 --> 00:04:13,230
当领导者刚刚重启
the server if this leader had just

82
00:04:13,230 --> 00:04:14,940
因为图2的规则说明
restarted because the figure 2 rules

83
00:04:14,940 --> 00:04:16,649
nextIndex是从新领导者的最后一条日志开始的
say that nextIndex starts out at the

84
00:04:16,649 --> 00:04:21,238
nextIndex是从新领导者的最后一条日志开始的
end of the new leader's log and so in

85
00:04:21,238 --> 00:04:23,760
所以为了应对回复的错误 领导者应该
response to errors the leaders supposed

86
00:04:23,760 --> 00:04:25,980
减小的它的nextIndex
to decrement its nextIndex

87
00:04:25,980 --> 00:04:28,470
所以它对两个回复错误的服务
so it does that for both got

88
00:04:28,470 --> 00:04:34,710
都减小了nextIndex 然后重新发送
errors from both ??? resends

89
00:04:34,710 --> 00:04:36,300
这次领导者将发送AppendEntries
and This time the server is going to

90
00:04:36,300 --> 00:04:38,450
这次领导者将发送AppendEntries
send out AppendEntries with

91
00:04:38,450 --> 00:04:41,780
其previousLogIndex等于11
previousLogIndex equals 11

92
00:04:41,780 --> 00:04:47,430
previousLogTerm等于3
and previousLogTerm equals 3 and This

93
00:04:47,430 --> 00:04:50,340
这个新的AppendEntries
new AppendEntries has it has a

94
00:04:50,340 --> 00:04:53,250
有了不同的previousLogIndex
different previousLogIndex but it's

95
00:04:53,250 --> 00:04:55,800
但是领导者这次将要发送的日志条目
the content in the log entries that the

96
00:04:55,800 --> 00:04:58,140
但是领导者这次将要发送的日志条目
server is going to send out this time

97
00:04:58,140 --> 00:05:01,410
包括了所有
include you know all the entries after

98
00:05:01,410 --> 00:05:03,420
在新previousLogIndex之后的条目
that the new previousLogIndex is

99
00:05:03,420 --> 00:05:06,240
所以现在对于服务#2来说
sending out so server 2 now the

100
00:05:06,240 --> 00:05:10,710
previousLogIndex是11 它在这里匹配
previousLogIndex 11 it looks there and it sees

101
00:05:10,710 --> 00:05:12,960
它发现任期是3
a ha you know the term is 3 same as what

102
00:05:12,960 --> 00:05:15,510
与领导者发送的任期相同
the leader is sending me so server 2 is

103
00:05:15,510 --> 00:05:17,220
所以服务#2将接受这个AppendEntries
actually going to accept this AppendEntries

104
00:05:17,220 --> 00:05:20,520
图2的规则说明
and figure 2 rules say oh if you

105
00:05:20,520 --> 00:05:22,440
如果你接受了一个AppendEntries 我们应该
accept a AppendEntries we supposed to delete

106
00:05:22,440 --> 00:05:24,030
删除日志中所有在AppendEntries开始之后的部分
everything in your log after where the

107
00:05:24,030 --> 00:05:26,040
删除日志中所有在AppendEntries开始之后的部分
AppendEntries starts and replace it with

108
00:05:26,040 --> 00:05:28,340
用AppendEntries中的日志条目替换
whatever's in the AppendEntries so

109
00:05:28,340 --> 00:05:32,360
所以服务#2将这样做 
server 2 is going to do that now it's

110
00:05:32,810 --> 00:05:35,760
它将追加5和6 服务#1仍然有问题
he just went to 5 6 Server 1 still has a

111
00:05:35,760 --> 00:05:38,580
因为它的插槽#11是空的
problem because it has nothing at slot 11

112
00:05:38,580 --> 00:05:41,730
它将返回另外一个错误
It would return another error

113
00:05:41,730 --> 00:05:47,730
领导者会将服务#1的nextIndex变为11
The server will now backup its server 1 nextIndex

114
00:05:47,730 --> 00:05:51,240
它将发送从这之后的日志
to 11 it'll send out its log

115
00:05:51,240 --> 00:05:54,330
带有previousIndex和previousTerm
starting here with the previousIndex

116
00:05:54,330 --> 00:05:56,340
它们是根据这个插槽设置的
and term referring now to this slot and

117
00:05:56,340 --> 00:05:58,250
这次的请求可以被服务#1接受
this one's actually acceptable server 1

118
00:05:58,250 --> 00:06:00,990
它将会接受新的日志条目
it'll adopt it'll accept the new log

119
00:06:00,990 --> 00:06:03,120
并发送肯定的回复
entries and send a positive response

120
00:06:03,120 --> 00:06:06,740
给领导者  现在它们……
back to the server and now they're all

121
00:06:07,670 --> 00:06:13,880
它们都拥有最新的日志了
now they're all caught up and the

122
00:06:14,720 --> 00:06:17,880
领导者在看到跟随者
presumably the server also when it sees

123
00:06:17,880 --> 00:06:21,420
都接受了请求
that followers accepted and append

124
00:06:21,420 --> 00:06:22,920
且追加了一定数量的条目
entries that had a certain number of log

125
00:06:22,920 --> 00:06:24,360
它会增加nextIndex到14
entries it actually increments this nextIndex

126
00:06:24,360 --> 00:06:29,070
它会增加nextIndex到14
could be 14 14 all right so the

127
00:06:29,070 --> 00:06:31,020
所以这种复制方式的作用是
effect of all this backing up is that

128
00:06:31,020 --> 00:06:33,090
领导者使用一种复制机制
the server has used a backup mechanism

129
00:06:33,090 --> 00:06:36,770
来探测跟随者们的日志中
to detect the point at which the

130
00:06:36,770 --> 00:06:38,370
第一个与领导者的相同的位置
followers' logs started

131
00:06:38,370 --> 00:06:39,760
第一个与领导者的相同的位置
to be equal to this

132
00:06:39,760 --> 00:06:42,430
然后给每个跟随者发送
server's and then sent each of the

133
00:06:42,430 --> 00:06:43,900
从这个位置的
followers starting from that point that

134
00:06:43,900 --> 00:06:47,280
剩余全部的领导者日志
a complete remainder of the server's log

135
00:06:47,280 --> 00:06:49,810 
这之后 它们在最后一个位置的日志是相同的
After that last point at which they were

136
00:06:49,810 --> 00:07:01,890
有什么问题吗
equal any questions all right

137
00:07:01,920 --> 00:07:05,740
重复我们之前讨论过的
just to repeat discussion we've had

138
00:07:05,740 --> 00:07:07,990
可能已经
before and we'll probably have again you

139
00:07:07,990 --> 00:07:09,790
擦除了一些日志条目
notice that we erased some log entries

140
00:07:09,790 --> 00:07:11,740
他们是……
here which are now su erase that I

141
00:07:11,740 --> 00:07:15,010
4 和 5 
forget what they were 4 & 5 so there

142
00:07:15,010 --> 00:07:18,570
所以会有一些……
were some well actually that was mostly

143
00:07:18,570 --> 00:07:21,310
记住我们删除了这个服务#2的日志条目
remember we erased this log entry here

144
00:07:21,310 --> 00:07:24,760
曾经是4
this used to say 4 server 2 the

145
00:07:24,760 --> 00:07:27,460
问题是为什么系统忘记了
question is why was it ok for the system

146
00:07:27,460 --> 00:07:29,440
这条客户端的命令是OK的
to forget about this client command

147
00:07:29,440 --> 00:07:32,170
这条我们删除的条目对应了
right this thing we erased corresponds

148
00:07:32,170 --> 00:07:33,370
某个被丢弃的客户端命令
to some client command which are now

149
00:07:33,370 --> 00:07:36,970
我昨天曾经讨论过这个问题
throwing away I talked about this

150
00:07:36,970 --> 00:07:42,790
这里的原理是什么呢
yesterday what's the rationale here

151
00:07:42,790 --> 00:07:45,040
对的 它没有被服务的大多数所拥有
yeah so it's not a majority of the servers

152
00:07:45,040 --> 00:07:46,720
因此无论之前的领导者是谁
and therefore whatever previous leader

153
00:07:46,720 --> 00:07:49,300
发送的这条日志
it was who sent this out couldn't have

154
00:07:49,300 --> 00:07:51,310
都没有得到大多数服务的确认
gotten acknowledgments from a majority

155
00:07:51,310 --> 00:07:52,810
因此之前的领导者
of servers therefore that previous

156
00:07:52,810 --> 00:07:55,240
不可能决定提交它
leader couldn't have decided it was

157
00:07:55,240 --> 00:07:57,400
不可能执行它
committed couldn't have executed it and

158
00:07:57,400 --> 00:07:58,930
不可能把它应用到应用状态上
applied it to the application state

159
00:07:58,930 --> 00:08:00,970
不可能回复肯定的答复给客户端
could never have sent a positive reply

160
00:08:00,970 --> 00:08:03,580
不可能回复肯定的答复给客户端
back to the client so because this isn't

161
00:08:03,580 --> 00:08:05,320
因此它没有被大多数服务所完成
done a majority of servers we know that

162
00:08:05,320 --> 00:08:07,060
发送它的客户端没有理由
the client who send in and has no reason

163
00:08:07,060 --> 00:08:08,860
相信这条命令被执行了
to believe it was executed couldn't have

164
00:08:08,860 --> 00:08:10,240
不可能获得一个回复 因为其中一条规则是
gotten a reply because one of the rules

165
00:08:10,240 --> 00:08:12,940
领导者只回复给客户端
is the server only sends over the leader

166
00:08:12,940 --> 00:08:15,070
领导者只回复给客户端
only sends a reply to a client after it

167
00:08:15,070 --> 00:08:19,090
在命令被提交并且被执行后
commits and executes so the client had

168
00:08:19,090 --> 00:08:20,380
所以客户端没有理由认为
no reason to believe it was even

169
00:08:20,380 --> 00:08:23,380
命令被任何服务所接收了
received by any server and then and the

170
00:08:23,380 --> 00:08:24,730
图2的规则基本上说明了
rules of figure 2 basically say the

171
00:08:24,730 --> 00:08:26,590
如果客户端过了一段时间没有收到回复
client if he gets no response after a

172
00:08:26,590 --> 00:08:27,880
它应该重新发送请求
while it supposed to resend the request

173
00:08:27,880 --> 00:08:29,800
所以我们知道无论这个请求是什么
so we know whatever request this was it

174
00:08:29,800 --> 00:08:33,700
它都会被丢弃 我们从没有执行它
threw away we've never executed never

175
00:08:33,700 --> 00:08:36,039
没有把它包含在任何状态中
included in any state already and the

176
00:08:36,039 --> 00:08:41,159
客户端将在不久后重新发送它
clients gonna resend it by-and-by yes

177
00:08:58,440 --> 00:09:05,460
它总是会删除跟随者日志的后缀
Well it's always deleting suffix of the followers log 

178
00:09:05,460 --> 00:09:10,750
一个备选的答案是
I mean in the end the sort of backup answer to this is that

179
00:09:10,750 --> 00:09:13,840
领导者有完整的日志 所以那些请求都失败了
the leader has a complete log so all of its fails

180
00:09:13,840 --> 00:09:17,510
它可以发送完整的日志给跟随者
it can just send us complete log to the follower 

181
00:09:17,510 --> 00:09:19,270
事实上如果
and indeed if you know

182
00:09:19,270 --> 00:09:20,590
如果你刚刚启动这个系统
if you've just started up the system and

183
00:09:20,590 --> 00:09:22,390
甚至在一开始就发生了非常反常的事情
something very strange happened even at

184
00:09:22,390 --> 00:09:24,880
你可能要结束这个命令
the very beginning then you may end up

185
00:09:24,880 --> 00:09:26,140
事实上在lab2的一些测试用例中
actually you know maybe in some of the

186
00:09:26,140 --> 00:09:28,780
你可能要结束备份第一个条目
tests for lab two you may end up backing up

187
00:09:28,780 --> 00:09:31,330
你可能要结束备份第一个条目 
to the very first entry

188
00:09:31,330 --> 00:09:32,920
然后让领导者发送整个日志
and then having the leader essentially send the

189
00:09:32,920 --> 00:09:34,180
但是因为领导者拥有整个日志
whole log but because the leader has

190
00:09:34,180 --> 00:09:35,620
但是因为领导者拥有整个日志
this whole log we know it could sort of

191
00:09:35,620 --> 00:09:37,330
所以它拥有填充每个节点的日志所需的所有信息
it's got all the information that's

192
00:09:37,330 --> 00:09:42,330
所以它具有填充每个节点的日志所需的所有信息
required to fill everybody's logs if it needs to

193
00:09:49,260 --> 00:09:55,800
好的 在这个例子中 我想已经被擦掉了
okay all right so in this example which I guess are now erased

194
00:09:55,800 --> 00:09:57,850
我们选举S3作为领导者
we elected s3 as the leader 

195
00:09:57,850 --> 00:10:02,680
问题是哪些节点允许成为领导者
and the question is could we you know 

196
00:10:02,680 --> 00:10:04,870
问题是哪些节点允许成为领导者
who can we who are we allowed

197
00:10:04,870 --> 00:10:08,830
to elect this leader right cool

198
00:10:08,830 --> 00:10:10,840
you know that all right if you read the

199
00:10:10,840 --> 00:10:12,730
paper you know the answer is not just

200
00:10:12,730 --> 00:10:15,670
anyone it turns out it matters a lot for

201
00:10:15,670 --> 00:10:17,410
the correctness the correctness of the

202
00:10:17,410 --> 00:10:19,900
system that we don't allow just anyone

203
00:10:19,900 --> 00:10:21,670
to be the leader like for example the

204
00:10:21,670 --> 00:10:24,610
first node whose timer goes off may in

205
00:10:24,610 --> 00:10:28,150
fact not be an acceptable leader and so

206
00:10:28,150 --> 00:10:29,800
it turns out raft has some rules that

207
00:10:29,800 --> 00:10:32,620
applies about oh yes you can be leader

208
00:10:32,620 --> 00:10:35,440
or you can't be leader and to see why

209
00:10:35,440 --> 00:10:37,000
this is true let's sort of set up a

210
00:10:37,000 --> 00:10:43,090
straw man proposal that maybe raft

211
00:10:43,090 --> 00:10:46,120
should accept should use the server with

212
00:10:46,120 --> 00:10:49,210
the longest log as the leader right you

213
00:10:49,210 --> 00:10:50,830
know some alternate universe that could

214
00:10:50,830 --> 00:10:52,420
be true and it is actually true in

215
00:10:52,420 --> 00:10:55,000
systems with different designs just not

216
00:10:55,000 --> 00:10:57,340
in raft so the question we're

217
00:10:57,340 --> 00:11:02,260
investigating is why not use the

218
00:11:02,260 --> 00:11:09,910
cervical longest law as leader and this

219
00:11:09,910 --> 00:11:11,710
would involve changing the voting rules

220
00:11:11,710 --> 00:11:16,090
in raft have a voters only vote for

221
00:11:16,090 --> 00:11:19,600
nodes that have longer logs all right so

222
00:11:19,600 --> 00:11:21,610
the example that's going to be

223
00:11:21,610 --> 00:11:23,080
convenient for showing why this is a bad

224
00:11:23,080 --> 00:11:25,900
idea so let's imagine we have three

225
00:11:25,900 --> 00:11:29,980
servers again and now the log set setups

226
00:11:29,980 --> 00:11:34,360
are server Wan has entries for terms

227
00:11:34,360 --> 00:11:38,530
five six and seven server two four five

228
00:11:38,530 --> 00:11:41,950
and eight and server three also four

229
00:11:41,950 --> 00:11:46,900
five and eight that's the first question

230
00:11:46,900 --> 00:11:50,020
of course to avoid spending our time

231
00:11:50,020 --> 00:11:51,610
scratching our heads about utter

232
00:11:51,610 --> 00:11:54,520
nonsense is to make sure that convince

233
00:11:54,520 --> 00:11:56,320
ourselves that this configuration could

234
00:11:56,320 --> 00:11:58,060
actually arise because if it couldn't

235
00:11:58,060 --> 00:11:59,800
possibly arise then

236
00:11:59,800 --> 00:12:01,390
may be a waste of time to figure out

237
00:12:01,390 --> 00:12:03,760
what would happen if it did arise so

238
00:12:03,760 --> 00:12:07,630
anybody wanna propose a sequence of

239
00:12:07,630 --> 00:12:10,779
events whereby this set of logs could

240
00:12:10,779 --> 00:12:17,140
have arisen how about an argument that

241
00:12:17,140 --> 00:12:27,160
it couldn't have arisen oh yeah okay so

242
00:12:27,160 --> 00:12:31,650
well maybe we'll back up sometime

243
00:12:31,800 --> 00:12:34,450
all right so server one wins is wins the

244
00:12:34,450 --> 00:12:37,150
election at this point and it's in term

245
00:12:37,150 --> 00:12:42,520
six sends out yeah it receives a client

246
00:12:42,520 --> 00:12:44,020
request sends out the first append

247
00:12:44,020 --> 00:12:52,900
entries and then that's fine actually

248
00:12:52,900 --> 00:12:56,160
everything's fine so far nothing's wrong

249
00:12:56,790 --> 00:12:59,770
all right well a good bet for all these

250
00:12:59,770 --> 00:13:01,960
things is then it crashes right or it

251
00:13:01,960 --> 00:13:04,990
receives the client requests in term six

252
00:13:04,990 --> 00:13:06,790
it appends the client requests to its

253
00:13:06,790 --> 00:13:08,589
own log which it does first and it's

254
00:13:08,589 --> 00:13:10,270
about to send out a pen entries but it

255
00:13:10,270 --> 00:13:12,760
crashes yes it didn't send out any pen

256
00:13:12,760 --> 00:13:14,770
entries and then you know we need then

257
00:13:14,770 --> 00:13:16,510
it crashes and restarts very quickly

258
00:13:16,510 --> 00:13:19,360
there's a new election and gosh server

259
00:13:19,360 --> 00:13:22,089
one is elected again as the as the new

260
00:13:22,089 --> 00:13:24,460
leader it receives in term seven and

261
00:13:24,460 --> 00:13:25,839
receives a client request appends it to

262
00:13:25,839 --> 00:13:33,220
its log and then it crashes right and

263
00:13:33,220 --> 00:13:35,380
then after after a crashes we have a new

264
00:13:35,380 --> 00:13:37,360
election maybe server 2 gets elected

265
00:13:37,360 --> 00:13:42,580
this time maybe server 1 is down now so

266
00:13:42,580 --> 00:13:45,970
off the table if server 2 is elected at

267
00:13:45,970 --> 00:13:48,910
this point suppose server 1 is still

268
00:13:48,910 --> 00:13:51,339
dead what term is server what server two

269
00:13:51,339 --> 00:13:53,550
venues

270
00:13:56,420 --> 00:13:58,310
yeah eights the right answer so why

271
00:13:58,310 --> 00:14:00,710
eight and not remember this you know

272
00:14:00,710 --> 00:14:04,570
this is now gone why eight and not six

273
00:14:07,240 --> 00:14:09,620
that's absolutely right so not written

274
00:14:09,620 --> 00:14:11,270
on the board but in order for server one

275
00:14:11,270 --> 00:14:12,740
to have been elected here it must have

276
00:14:12,740 --> 00:14:14,150
votes from majority of nodes which

277
00:14:14,150 --> 00:14:16,690
include at least one of server-to-server

278
00:14:16,690 --> 00:14:21,100
three if you look at the vote request

279
00:14:21,100 --> 00:14:24,380
code and figure two if you vote for

280
00:14:24,380 --> 00:14:25,640
somebody you're you're supposed to

281
00:14:25,640 --> 00:14:30,010
record the term in persistent storage

282
00:14:30,010 --> 00:14:32,900
and that means that either server 2 or

283
00:14:32,900 --> 00:14:35,150
server 3 are both new about term six and

284
00:14:35,150 --> 00:14:38,030
in fact term seven and therefore when

285
00:14:38,030 --> 00:14:39,710
sever one dies and they cannot elect a

286
00:14:39,710 --> 00:14:41,750
new leader at least one of them knows

287
00:14:41,750 --> 00:14:44,930
that the current term was eight if that

288
00:14:44,930 --> 00:14:48,020
one and only that one actually if

289
00:14:48,020 --> 00:14:49,100
there's only one of them only that one

290
00:14:49,100 --> 00:14:51,230
could win an election because it has the

291
00:14:51,230 --> 00:14:52,400
higher terminal birth they both know

292
00:14:52,400 --> 00:14:53,840
about term eight sorry if they both know

293
00:14:53,840 --> 00:14:56,150
about term seven then they'll both and

294
00:14:56,150 --> 00:14:57,740
either one of them will try to be leader

295
00:14:57,740 --> 00:15:00,530
and term eight so that fact of that the

296
00:15:00,530 --> 00:15:02,960
next term must be term a dis is insured

297
00:15:02,960 --> 00:15:05,090
by the property of the majorities must

298
00:15:05,090 --> 00:15:08,060
overlap and the fact that current term

299
00:15:08,060 --> 00:15:10,490
is updated by vote request and is

300
00:15:10,490 --> 00:15:12,710
persistent and guarantee did not be lost

301
00:15:12,710 --> 00:15:14,810
even if there were some crashes here so

302
00:15:14,810 --> 00:15:15,650
the next term is going to be eight

303
00:15:15,650 --> 00:15:17,360
server two or server three will win the

304
00:15:17,360 --> 00:15:19,490
leadership election and let's just

305
00:15:19,490 --> 00:15:21,350
imagine that whichever one it is sends

306
00:15:21,350 --> 00:15:25,820
out append entries for a new client

307
00:15:25,820 --> 00:15:27,380
requests the other one gets it and so

308
00:15:27,380 --> 00:15:30,020
now we have this configuration right so

309
00:15:30,020 --> 00:15:32,630
I was a bit of a detour we're back to

310
00:15:32,630 --> 00:15:36,080
our original question of in this

311
00:15:36,080 --> 00:15:38,150
configuration suppose server one revives

312
00:15:38,150 --> 00:15:42,860
we have an election would it be okay to

313
00:15:42,860 --> 00:15:44,720
use server one would it be okay to have

314
00:15:44,720 --> 00:15:48,890
the rule be the longest log wins the

315
00:15:48,890 --> 00:15:54,290
longest log gets to be the leader yeah

316
00:15:54,290 --> 00:15:56,690
obviously not right because server was a

317
00:15:56,690 --> 00:16:04,460
leader did it's going to force its log

318
00:16:04,460 --> 00:16:07,250
on to the to followers by the append

319
00:16:07,250 --> 00:16:08,570
entries machinery that we just talked

320
00:16:08,570 --> 00:16:09,950
about a few minutes ago

321
00:16:09,950 --> 00:16:11,390
if we live server one to be the leader

322
00:16:11,390 --> 00:16:13,850
it's gonna you know sent out a pen

323
00:16:13,850 --> 00:16:15,710
entries whatever backup overwrite these

324
00:16:15,710 --> 00:16:19,040
aids tell the followers to erase their

325
00:16:19,040 --> 00:16:21,470
log entries for term a to accept to

326
00:16:21,470 --> 00:16:23,480
overwrite them with this six and seven

327
00:16:23,480 --> 00:16:26,080
log entries and then to proceed now with

328
00:16:26,080 --> 00:16:30,380
identical to server ones so of course

329
00:16:30,380 --> 00:16:39,860
why are we upset about this yeah yeah

330
00:16:39,860 --> 00:16:43,070
exactly it was already committed right

331
00:16:43,070 --> 00:16:45,410
it's not a majority of servers has

332
00:16:45,410 --> 00:16:50,060
already committed probably executed

333
00:16:50,060 --> 00:16:52,670
quite possibly a reply sent to a client

334
00:16:52,670 --> 00:16:56,510
so we're not entitled to delete it and

335
00:16:56,510 --> 00:17:00,110
therefore server one cannot be allowed

336
00:17:00,110 --> 00:17:02,660
to become leader and force its log onto

337
00:17:02,660 --> 00:17:06,170
servers two and three everybody see why

338
00:17:06,170 --> 00:17:12,050
that's bad idea for rapid and because of

339
00:17:12,050 --> 00:17:15,920
that this can't possibly have been rule

340
00:17:15,920 --> 00:17:19,970
for elections of course shortest log

341
00:17:19,970 --> 00:17:23,780
didn't work too well either and so in

342
00:17:23,780 --> 00:17:26,900
fact if you read forward to section

343
00:17:26,900 --> 00:17:31,300
something five point four point one

344
00:17:32,950 --> 00:17:34,910
draft actually has a slightly more

345
00:17:34,910 --> 00:17:41,380
sophisticated election restriction that

346
00:17:43,960 --> 00:17:47,120
the request vote handling RPC handling

347
00:17:47,120 --> 00:17:49,520
code is supposed to check before it says

348
00:17:49,520 --> 00:17:51,740
yes before votes yes for a different

349
00:17:51,740 --> 00:18:00,050
peer and the rule is we only vote you

350
00:18:00,050 --> 00:18:02,630
vote yes for some candidate who send us

351
00:18:02,630 --> 00:18:10,730
over request votes only if candidate has

352
00:18:10,730 --> 00:18:13,990
a higher

353
00:18:15,050 --> 00:18:26,809
term in the last log entry or same last

354
00:18:26,809 --> 00:18:31,450
term same charming the last log entry

355
00:18:31,450 --> 00:18:38,090
and a log length that's greater than or

356
00:18:38,090 --> 00:18:44,720
equal to the the server that received

357
00:18:44,720 --> 00:18:51,740
that received the boat request and so if

358
00:18:51,740 --> 00:18:53,840
we apply this here if server two gets a

359
00:18:53,840 --> 00:18:58,400
vote request from server one there our

360
00:18:58,400 --> 00:19:03,410
last log entry terms or seven the server

361
00:19:03,410 --> 00:19:04,670
one's gonna send out a request votes

362
00:19:04,670 --> 00:19:08,150
with a last entry term whatever of 7

363
00:19:08,150 --> 00:19:11,920
server twos is eight so this isn't true

364
00:19:11,920 --> 00:19:14,900
server service we didn't get a request

365
00:19:14,900 --> 00:19:16,370
from somebody with a higher term in the

366
00:19:16,370 --> 00:19:22,220
last entry and or the last entry terms

367
00:19:22,220 --> 00:19:23,480
aren't the same either said the second

368
00:19:23,480 --> 00:19:26,540
Clause doesn't apply either so neither

369
00:19:26,540 --> 00:19:28,460
server to new serve nor server three is

370
00:19:28,460 --> 00:19:30,470
going to vote for server one and so even

371
00:19:30,470 --> 00:19:32,240
if it sends out this vote requests first

372
00:19:32,240 --> 00:19:33,650
because this has a shorter election

373
00:19:33,650 --> 00:19:35,510
timeout nobody's going to vote for it

374
00:19:35,510 --> 00:19:36,830
except itself so I don't think it's one

375
00:19:36,830 --> 00:19:38,900
vote it's not a majority if either

376
00:19:38,900 --> 00:19:41,900
server two or server three becomes a

377
00:19:41,900 --> 00:19:44,630
candidate then either of them will

378
00:19:44,630 --> 00:19:45,920
accept the other because they have the

379
00:19:45,920 --> 00:19:48,260
same last term number and their logs are

380
00:19:48,260 --> 00:19:50,000
each greater than or equal to in length

381
00:19:50,000 --> 00:19:52,280
and the others so either of them will

382
00:19:52,280 --> 00:19:55,040
vote for for the other one will server

383
00:19:55,040 --> 00:19:56,920
one vote for either of them

384
00:19:56,920 --> 00:20:00,140
yes because either server 2 or server 3

385
00:20:00,140 --> 00:20:01,370
has a higher term number in the last

386
00:20:01,370 --> 00:20:05,960
entry so you know what this is doing is

387
00:20:05,960 --> 00:20:07,940
making sure that you can only become a

388
00:20:07,940 --> 00:20:11,780
candidate if or it prefers candidates

389
00:20:11,780 --> 00:20:13,460
that knew about higher that have log

390
00:20:13,460 --> 00:20:15,710
entries some higher terms that is it

391
00:20:15,710 --> 00:20:17,090
prefers candidates that are more likely

392
00:20:17,090 --> 00:20:18,679
to have been receiving log entries from

393
00:20:18,679 --> 00:20:23,750
the previous leader and you know this

394
00:20:23,750 --> 00:20:25,400
second part says well we were all

395
00:20:25,400 --> 00:20:26,809
listening to the previous leader then

396
00:20:26,809 --> 00:20:27,380
we're going to

397
00:20:27,380 --> 00:20:30,500
for the server that has saw more

398
00:20:30,500 --> 00:20:35,540
requests from the very last leader any

399
00:20:35,540 --> 00:20:40,510
questions about the election restriction

400
00:20:45,520 --> 00:20:55,070
okay final thing about sending out log

401
00:20:55,070 --> 00:20:59,510
entries is that this rollback scheme at

402
00:20:59,510 --> 00:21:01,460
least as I described it and it's as its

403
00:21:01,460 --> 00:21:03,679
described in Figure two rolls back one

404
00:21:03,679 --> 00:21:08,030
log entry at a time and you know

405
00:21:08,030 --> 00:21:09,559
probably a lot of fun that's okay

406
00:21:09,559 --> 00:21:13,100
but there are situations maybe in the

407
00:21:13,100 --> 00:21:15,290
real world and definitely in the lab

408
00:21:15,290 --> 00:21:18,530
tests where backing up one entry at a

409
00:21:18,530 --> 00:21:20,120
time is going to take a long long time

410
00:21:20,120 --> 00:21:22,400
and so the real-world situation where

411
00:21:22,400 --> 00:21:25,820
that might be true is if they if a

412
00:21:25,820 --> 00:21:27,950
follower has been down for a long time

413
00:21:27,950 --> 00:21:30,170
and missed a lot of upend entries and

414
00:21:30,170 --> 00:21:33,110
the leader restarts and if you follow

415
00:21:33,110 --> 00:21:34,670
the pseudocode in Figure two if a leader

416
00:21:34,670 --> 00:21:36,230
restarts is supposed to set its next

417
00:21:36,230 --> 00:21:38,570
index to the end of the leaders log so

418
00:21:38,570 --> 00:21:40,190
if the follower has been down and you

419
00:21:40,190 --> 00:21:42,559
know miss the last thousand log entries

420
00:21:42,559 --> 00:21:45,620
and leader reboots the leader is gonna

421
00:21:45,620 --> 00:21:48,350
have to walk back off one at a time one

422
00:21:48,350 --> 00:21:50,960
RPC at a time all thousand of those log

423
00:21:50,960 --> 00:21:53,840
entries that the follower missed and

424
00:21:53,840 --> 00:21:55,190
there's no you know particular reason

425
00:21:55,190 --> 00:21:57,590
why this would never happen in real life

426
00:21:57,590 --> 00:22:01,160
it could easily happen at somewhat more

427
00:22:01,160 --> 00:22:03,950
contrived situation that the tests are

428
00:22:03,950 --> 00:22:07,190
definitely explorers is if a follower is

429
00:22:07,190 --> 00:22:09,890
if we say we have five servers and

430
00:22:09,890 --> 00:22:13,910
there's there's a leader but the leaders

431
00:22:13,910 --> 00:22:17,000
got trapped with one follower in a

432
00:22:17,000 --> 00:22:18,440
network partition but the leader doesn't

433
00:22:18,440 --> 00:22:19,790
know it's not leader anymore and it's

434
00:22:19,790 --> 00:22:21,920
still sending out append entries to its

435
00:22:21,920 --> 00:22:23,150
one follower and none of which are

436
00:22:23,150 --> 00:22:25,940
committed while in the other majority

437
00:22:25,940 --> 00:22:28,730
partition the system is continuing as

438
00:22:28,730 --> 00:22:32,500
usual the ex leader and follower in that

439
00:22:32,500 --> 00:22:35,690
Minority partition could end up putting

440
00:22:35,690 --> 00:22:37,490
in their logs you know sort of unlimited

441
00:22:37,490 --> 00:22:40,790
numbers of log entries for a stale term

442
00:22:40,790 --> 00:22:42,260
that will never be committed and need to

443
00:22:42,260 --> 00:22:44,240
be deleted and overwritten eventually

444
00:22:44,240 --> 00:22:47,600
when they rejoin the main group that's

445
00:22:47,600 --> 00:22:48,740
maybe a little less likely in the real

446
00:22:48,740 --> 00:22:52,520
world but you'll see it happen and the

447
00:22:52,520 --> 00:22:55,280
test set up so in order to be able to

448
00:22:55,280 --> 00:22:57,610
back up faster that paper has

449
00:22:57,610 --> 00:22:59,950
somewhat a vague description of a faster

450
00:22:59,950 --> 00:23:05,010
scheme towards the end of section 5.3

451
00:23:05,010 --> 00:23:07,300
it's a little bit hard to interpret so

452
00:23:07,300 --> 00:23:10,150
I'm gonna try to explain what their

453
00:23:10,150 --> 00:23:11,650
ideas about how to back up faster a

454
00:23:11,650 --> 00:23:13,270
little bit better and the general idea

455
00:23:13,270 --> 00:23:15,520
is to be able to to have the follower

456
00:23:15,520 --> 00:23:17,380
send enough information to the leader

457
00:23:17,380 --> 00:23:19,630
that the leader can jump back an entire

458
00:23:19,630 --> 00:23:22,960
terms worth of entries that have to be

459
00:23:22,960 --> 00:23:26,140
deleted per append entries so it leader

460
00:23:26,140 --> 00:23:27,580
may only have to send one in a pennant

461
00:23:27,580 --> 00:23:30,880
and append entries per term in which the

462
00:23:30,880 --> 00:23:33,850
leader and follower disagree instead of

463
00:23:33,850 --> 00:23:38,080
one per entry so there's three cases I

464
00:23:38,080 --> 00:23:39,910
think are important and the fact is that

465
00:23:39,910 --> 00:23:42,960
you can probably think of many different

466
00:23:42,960 --> 00:23:46,620
log backup acceleration strategies and

467
00:23:46,620 --> 00:23:50,170
here's one so I'm going to divide the

468
00:23:50,170 --> 00:23:51,880
kinds of situations you might see into

469
00:23:51,880 --> 00:24:01,480
three cases so this is fast backup case

470
00:24:01,480 --> 00:24:06,940
one I'm just going to talk about one

471
00:24:06,940 --> 00:24:09,280
follower and the leader and not worry

472
00:24:09,280 --> 00:24:12,100
about the other nodes the same we have

473
00:24:12,100 --> 00:24:18,040
two server one which is the follower and

474
00:24:18,040 --> 00:24:25,570
server 2 which is the leader so this is

475
00:24:25,570 --> 00:24:29,080
one case and here we need to backup over

476
00:24:29,080 --> 00:24:31,030
a term where that term is entirely

477
00:24:31,030 --> 00:24:39,600
missing from the leader another case

478
00:24:44,640 --> 00:24:47,680
so in this case we need to back up over

479
00:24:47,680 --> 00:24:49,180
some entries but their entries for a

480
00:24:49,180 --> 00:24:50,410
term that the leader actually knows

481
00:24:50,410 --> 00:24:53,980
about so apparently the this followers

482
00:24:53,980 --> 00:24:56,800
saw a couple of entry a couple of the

483
00:24:56,800 --> 00:24:58,960
very Flass few append entries sent out

484
00:24:58,960 --> 00:25:01,900
by a leader that was about to crash but

485
00:25:01,900 --> 00:25:03,640
the new leader didn't see them we still

486
00:25:03,640 --> 00:25:05,860
need to back up over them and a third

487
00:25:05,860 --> 00:25:11,680
case is where the followers entirely

488
00:25:11,680 --> 00:25:15,210
missing the following the leader agree

489
00:25:15,210 --> 00:25:19,900
but the followers is missing the end of

490
00:25:19,900 --> 00:25:24,790
the leaders log and I believe you can

491
00:25:24,790 --> 00:25:27,210
take care of all three of these with

492
00:25:27,210 --> 00:25:29,920
three pieces of extra information in the

493
00:25:29,920 --> 00:25:32,140
reply that a follower sends back to the

494
00:25:32,140 --> 00:25:35,590
leader in the case in the append entries

495
00:25:35,590 --> 00:25:37,300
so we're talking about the append

496
00:25:37,300 --> 00:25:42,220
entries reply if the follower rejects

497
00:25:42,220 --> 00:25:43,930
the append entries because the logs

498
00:25:43,930 --> 00:25:46,210
don't agree there's three pieces of

499
00:25:46,210 --> 00:25:47,500
information that will be useful and

500
00:25:47,500 --> 00:25:49,990
taking care of three street cases I'll

501
00:25:49,990 --> 00:25:55,450
call them X term which is the term of

502
00:25:55,450 --> 00:25:58,300
the conflicting entry I remember the

503
00:25:58,300 --> 00:26:05,460
leader sent this previous log term and

504
00:26:05,460 --> 00:26:07,810
if the follower rejects it because it

505
00:26:07,810 --> 00:26:09,040
has something here but the terms wrong

506
00:26:09,040 --> 00:26:12,880
so it'll put the followers term for the

507
00:26:12,880 --> 00:26:19,330
conflicting entry here or you know I'm

508
00:26:19,330 --> 00:26:21,040
negative one or something it doesn't

509
00:26:21,040 --> 00:26:25,030
have anything in the log there it'll

510
00:26:25,030 --> 00:26:30,220
also send back the index of the

511
00:26:30,220 --> 00:26:33,310
conflicting but the index are the first

512
00:26:33,310 --> 00:26:36,240
entry with that term

513
00:26:46,750 --> 00:26:49,840
and finally if there wasn't any log

514
00:26:49,840 --> 00:26:52,750
entry there at all the follower will

515
00:26:52,750 --> 00:26:56,860
send back on the length of its law like

516
00:26:56,860 --> 00:27:02,470
the followers log so for case one the

517
00:27:02,470 --> 00:27:12,790
way this helps if the it's a leader sees

518
00:27:12,790 --> 00:27:16,150
that the leader doesn't even have an

519
00:27:16,150 --> 00:27:19,030
entry with X term of term X term at all

520
00:27:19,030 --> 00:27:22,870
in its log so that's this case where the

521
00:27:22,870 --> 00:27:24,400
leader didn't have turn five and if the

522
00:27:24,400 --> 00:27:26,260
leader can simply back up to the

523
00:27:26,260 --> 00:27:30,570
beginning of the followers run of

524
00:27:30,570 --> 00:27:34,020
entries with X term that is the the

525
00:27:34,020 --> 00:27:37,000
leader can set its next index to this X

526
00:27:37,000 --> 00:27:41,650
index thing which is the first entry the

527
00:27:41,650 --> 00:27:45,179
followers run of items from term five

528
00:27:45,179 --> 00:27:48,460
alright so if the leader doesn't have X

529
00:27:48,460 --> 00:27:51,070
term at all it should back up to X back

530
00:27:51,070 --> 00:27:53,710
the follower up to X index the second

531
00:27:53,710 --> 00:27:55,570
case you can detect the fault the leader

532
00:27:55,570 --> 00:27:59,770
can detect if X term is valid and the

533
00:27:59,770 --> 00:28:04,900
leader actually has log entries of term

534
00:28:04,900 --> 00:28:08,280
X term that's the case here where the

535
00:28:08,280 --> 00:28:10,510
you know the disagreement is here but

536
00:28:10,510 --> 00:28:12,820
the leader actually has some entries

537
00:28:12,820 --> 00:28:14,890
that term in that case the leader should

538
00:28:14,890 --> 00:28:18,510
back up to the last entry it has that

539
00:28:18,510 --> 00:28:22,929
has the contesta followers term for the

540
00:28:22,929 --> 00:28:24,790
conflicting term in it that is the last

541
00:28:24,790 --> 00:28:26,919
entry that a leader has for term for in

542
00:28:26,919 --> 00:28:29,710
this case and if neither of these two

543
00:28:29,710 --> 00:28:33,130
cases hold that is the well actually if

544
00:28:33,130 --> 00:28:36,010
the follower indicates by maybe setting

545
00:28:36,010 --> 00:28:37,660
X term to minus one it actually didn't

546
00:28:37,660 --> 00:28:39,520
have anything whatsoever at the

547
00:28:39,520 --> 00:28:41,919
conflicting log and index because it's

548
00:28:41,919 --> 00:28:46,960
log is too short then the leader should

549
00:28:46,960 --> 00:28:49,780
back up its next index to the last entry

550
00:28:49,780 --> 00:28:51,400
that the follower had at all and start

551
00:28:51,400 --> 00:28:53,840
sending from there

552
00:28:53,840 --> 00:28:55,830
and I'm telling you this because it'll

553
00:28:55,830 --> 00:29:00,650
be useful for doing a lab and if you

554
00:29:00,650 --> 00:29:03,090
miss some of my description it's it's in

555
00:29:03,090 --> 00:29:05,130
electronics then any questions about

556
00:29:05,130 --> 00:29:20,970
this backing up business Jack I think

557
00:29:20,970 --> 00:29:25,080
that's true yeah yeah yeah maybe binary

558
00:29:25,080 --> 00:29:26,880
search I'm not ruling out other

559
00:29:26,880 --> 00:29:29,610
solutions I mean that you know after

560
00:29:29,610 --> 00:29:32,130
reading the papers non description of

561
00:29:32,130 --> 00:29:34,470
how to do it I like cook this up and

562
00:29:34,470 --> 00:29:37,530
there's probably other ways to do this

563
00:29:37,530 --> 00:29:39,060
probably better ways and faster ways of

564
00:29:39,060 --> 00:29:40,590
doing it like I'm I'm sure that if

565
00:29:40,590 --> 00:29:41,880
you're willing to send back more

566
00:29:41,880 --> 00:29:43,890
information or have a more sophisticated

567
00:29:43,890 --> 00:29:46,020
strategy like binary search you can do a

568
00:29:46,020 --> 00:29:50,550
better job yeah well you you almost

569
00:29:50,550 --> 00:29:53,150
certainly need to do something

570
00:29:53,150 --> 00:29:55,140
experience suggests that in order to

571
00:29:55,140 --> 00:29:57,600
pass the tests you'll need to do

572
00:29:57,600 --> 00:30:02,040
something to as well probably not me

573
00:30:02,040 --> 00:30:04,950
although I that's not quite true like

574
00:30:04,950 --> 00:30:06,420
one of the solutions I've written over

575
00:30:06,420 --> 00:30:08,550
the years actually does the stupid thing

576
00:30:08,550 --> 00:30:11,490
and still passes the tests but because

577
00:30:11,490 --> 00:30:15,990
the tests you know the one of the sort

578
00:30:15,990 --> 00:30:17,430
of unfortunate but inevitable things

579
00:30:17,430 --> 00:30:19,410
about the tests we give you is that they

580
00:30:19,410 --> 00:30:21,660
have a bit of a real time requirement

581
00:30:21,660 --> 00:30:23,250
that is the tests are not willing to

582
00:30:23,250 --> 00:30:25,590
wait forever for your solution to

583
00:30:25,590 --> 00:30:29,370
produce an answer so it is possible to

584
00:30:29,370 --> 00:30:30,720
have a solution that's you know

585
00:30:30,720 --> 00:30:33,930
technically correct but takes so long

586
00:30:33,930 --> 00:30:36,710
that the tester gives up and

587
00:30:36,710 --> 00:30:39,060
unfortunately you know we will the

588
00:30:39,060 --> 00:30:40,830
tester will fail you if your solution

589
00:30:40,830 --> 00:30:42,810
doesn't finish the test and whatever the

590
00:30:42,810 --> 00:30:44,790
time limit is and therefore you do

591
00:30:44,790 --> 00:30:46,940
actually have to pay some attention to

592
00:30:46,940 --> 00:30:50,460
performance in order you know your

593
00:30:50,460 --> 00:30:52,470
solution has to be both correct and have

594
00:30:52,470 --> 00:30:54,090
enough performance to finish before the

595
00:30:54,090 --> 00:30:56,490
tester gets bored and sometimes out on

596
00:30:56,490 --> 00:30:58,260
you which is like 10 minutes or I don't

597
00:30:58,260 --> 00:31:00,390
know what it is and unfortunately it's

598
00:31:00,390 --> 00:31:02,280
relatively this stuff's complex enough

599
00:31:02,280 --> 00:31:04,650
that it's not that hard to write a color

600
00:31:04,650 --> 00:31:05,210
correction

601
00:31:05,210 --> 00:31:15,350
that's not fast enough yes so the way

602
00:31:15,350 --> 00:31:16,850
you can tap the leader can tell the

603
00:31:16,850 --> 00:31:20,720
difference is that the follower we're

604
00:31:20,720 --> 00:31:23,120
supposed to send back the term number it

605
00:31:23,120 --> 00:31:25,730
sees in the conflicting entry you we

606
00:31:25,730 --> 00:31:29,120
have case one if the leader does not

607
00:31:29,120 --> 00:31:31,360
have that term in its log

608
00:31:31,360 --> 00:31:34,880
so here the follower will set X term to

609
00:31:34,880 --> 00:31:37,580
five to five because this is this is

610
00:31:37,580 --> 00:31:39,919
going to be the this is gonna be the

611
00:31:39,919 --> 00:31:44,210
conflicting entry the follower says this

612
00:31:44,210 --> 00:31:46,370
X term to five the leader observes oh I

613
00:31:46,370 --> 00:31:48,740
do not have term five in my log and

614
00:31:48,740 --> 00:31:57,200
therefore this case one and you know it

615
00:31:57,200 --> 00:31:58,100
should back up to the beginning

616
00:31:58,100 --> 00:32:00,169
like it doesn't follower hasn't leader

617
00:32:00,169 --> 00:32:02,539
has none of those and term five entry so

618
00:32:02,539 --> 00:32:04,130
it should just get rid of all of them in

619
00:32:04,130 --> 00:32:05,779
the follower by backing up to the

620
00:32:05,779 --> 00:32:20,120
beginning which is X index yeah yeah

621
00:32:20,120 --> 00:32:22,490
because the leaders gonna back up its

622
00:32:22,490 --> 00:32:25,909
next index to here and then send an

623
00:32:25,909 --> 00:32:28,039
append entries that starts here and the

624
00:32:28,039 --> 00:32:29,899
rules a figure to say ah the follower

625
00:32:29,899 --> 00:32:31,940
just has to replace its log so it is

626
00:32:31,940 --> 00:32:37,820
gonna get rid of the fives okay alright

627
00:32:37,820 --> 00:32:38,929
the next thing I want to talk about is

628
00:32:38,929 --> 00:32:42,140
persistence you'll notice in Figure two

629
00:32:42,140 --> 00:32:44,510
that the state in the upper left-hand

630
00:32:44,510 --> 00:32:47,750
corners sort of divided and summer

631
00:32:47,750 --> 00:32:50,830
marked persistent and some are marked

632
00:32:50,830 --> 00:32:54,649
volatile and what's going on here is

633
00:32:54,649 --> 00:32:57,649
that the the distinction between

634
00:32:57,649 --> 00:32:59,899
persistence and volatile you know only

635
00:32:59,899 --> 00:33:03,559
matters if a server reboots crashes and

636
00:33:03,559 --> 00:33:06,260
restarts because the persistent what the

637
00:33:06,260 --> 00:33:08,210
persistent means is that if you change

638
00:33:08,210 --> 00:33:09,740
one of those items it's marked

639
00:33:09,740 --> 00:33:14,120
persistent you're supposed to the server

640
00:33:14,120 --> 00:33:15,710
supposed to write it to disk or to some

641
00:33:15,710 --> 00:33:17,929
other non-volatile storage like as

642
00:33:17,929 --> 00:33:20,799
or battery-backed something or whatever

643
00:33:20,799 --> 00:33:23,450
that will ensure that if the server

644
00:33:23,450 --> 00:33:26,330
restarts that it will be able to find

645
00:33:26,330 --> 00:33:28,490
that information and sort of reload it

646
00:33:28,490 --> 00:33:34,159
into memory and that's to allow us to

647
00:33:34,159 --> 00:33:35,990
allow servers to be able to pick up

648
00:33:35,990 --> 00:33:37,940
where they left off if they crash and

649
00:33:37,940 --> 00:33:46,399
restart now you might think that it

650
00:33:46,399 --> 00:33:48,169
would it would be sufficient and simpler

651
00:33:48,169 --> 00:33:51,710
to say well if a server crashes then we

652
00:33:51,710 --> 00:33:55,879
just throw it away and or we need to be

653
00:33:55,879 --> 00:33:57,559
able to throw it away and replace it

654
00:33:57,559 --> 00:33:59,090
with a brand-new empty server and bring

655
00:33:59,090 --> 00:34:01,970
it up to speed right and of course you

656
00:34:01,970 --> 00:34:04,610
do actually it is vital to be able to do

657
00:34:04,610 --> 00:34:06,590
that right because if some server

658
00:34:06,590 --> 00:34:08,179
suffers a failure of some catastrophic

659
00:34:08,179 --> 00:34:10,790
failure like it's you know disk melts or

660
00:34:10,790 --> 00:34:14,480
something you absolutely need to be able

661
00:34:14,480 --> 00:34:17,119
to replace it and you cannot count on

662
00:34:17,119 --> 00:34:18,889
getting anything useful off its disk if

663
00:34:18,889 --> 00:34:20,719
something bad happened to its disk so we

664
00:34:20,719 --> 00:34:22,040
absolutely need to be able to replace

665
00:34:22,040 --> 00:34:24,859
completely replace servers that have no

666
00:34:24,859 --> 00:34:28,369
state whatsoever you might think that's

667
00:34:28,369 --> 00:34:30,379
sufficient to handle any difficulties

668
00:34:30,379 --> 00:34:32,599
but it's actually not it turns out that

669
00:34:32,599 --> 00:34:34,760
another common failure mode is power

670
00:34:34,760 --> 00:34:38,540
failure of you know the entire cluster

671
00:34:38,540 --> 00:34:40,699
where they all stop executing at the

672
00:34:40,699 --> 00:34:43,129
same time right and in that case we

673
00:34:43,129 --> 00:34:46,790
can't handle or we can't handle that

674
00:34:46,790 --> 00:34:48,679
failure by simply throwing away the

675
00:34:48,679 --> 00:34:50,719
servers and replacing them with new

676
00:34:50,719 --> 00:34:53,750
hardware that we buy from Dell we

677
00:34:53,750 --> 00:34:56,480
actually have to be able to get off the

678
00:34:56,480 --> 00:34:58,970
ground we need to be able to get a copy

679
00:34:58,970 --> 00:35:01,640
of the state back in order to keep

680
00:35:01,640 --> 00:35:04,130
executing if we want our service to be

681
00:35:04,130 --> 00:35:07,010
fault tolerant and therefore in order at

682
00:35:07,010 --> 00:35:09,290
least in order to handle the situation

683
00:35:09,290 --> 00:35:11,690
of simultaneous power failure we have to

684
00:35:11,690 --> 00:35:13,400
have a way for the server's to sort of

685
00:35:13,400 --> 00:35:15,319
save their state somewhere where it will

686
00:35:15,319 --> 00:35:19,040
be available when the power returns and

687
00:35:19,040 --> 00:35:20,569
that's one way of viewing what's going

688
00:35:20,569 --> 00:35:23,960
on with persistence it said that's the

689
00:35:23,960 --> 00:35:26,490
state that's required

690
00:35:26,490 --> 00:35:28,859
to get a server going again I'm after

691
00:35:28,859 --> 00:35:31,200
either a single power failure or power

692
00:35:31,200 --> 00:35:33,589
failure of the entire cluster

693
00:35:33,589 --> 00:35:38,609
alright so figure two this three items

694
00:35:38,609 --> 00:35:42,500
only three items are persistent so

695
00:35:44,900 --> 00:35:49,200
there's a log that's like all the log

696
00:35:49,200 --> 00:36:03,779
entries current term and voted for and

697
00:36:03,779 --> 00:36:06,089
by the way you know one of us server

698
00:36:06,089 --> 00:36:07,559
reboots it actually has to make an

699
00:36:07,559 --> 00:36:09,839
explicit check to make sure that these

700
00:36:09,839 --> 00:36:14,849
data are valid on its disk before it

701
00:36:14,849 --> 00:36:17,220
rejoins the raft cluster I have to have

702
00:36:17,220 --> 00:36:18,869
some way of saying oh yeah I actually do

703
00:36:18,869 --> 00:36:20,400
have some save persistent state as

704
00:36:20,400 --> 00:36:24,180
opposed to a bunch of zeros that that

705
00:36:24,180 --> 00:36:28,380
are not valid all right so the reason

706
00:36:28,380 --> 00:36:34,170
why log has to be persisted is that at

707
00:36:34,170 --> 00:36:36,029
least according to figure two this is

708
00:36:36,029 --> 00:36:40,160
the only record of the application state

709
00:36:40,160 --> 00:36:42,119
that is figure two doesn't really have a

710
00:36:42,119 --> 00:36:44,160
notion fears two does not say that we

711
00:36:44,160 --> 00:36:46,260
have to persist the application state so

712
00:36:46,260 --> 00:36:48,329
if we're running a database or you know

713
00:36:48,329 --> 00:36:50,549
a test and set service like for vmware

714
00:36:50,549 --> 00:36:53,309
ft the actual database or the actual

715
00:36:53,309 --> 00:36:55,049
value of the test and set flag isn't

716
00:36:55,049 --> 00:36:57,210
persistent according to figure two only

717
00:36:57,210 --> 00:36:59,250
the logins and so when the server

718
00:36:59,250 --> 00:37:02,160
restarts the only information available

719
00:37:02,160 --> 00:37:05,220
to reconstruct the application state is

720
00:37:05,220 --> 00:37:08,460
the sequence of commands in the log and

721
00:37:08,460 --> 00:37:13,440
so that has to be persisted that's what

722
00:37:13,440 --> 00:37:17,369
about current term why does current term

723
00:37:17,369 --> 00:37:20,329
have to be persistent

724
00:37:34,589 --> 00:37:37,030
yeah so they're both about ensuring that

725
00:37:37,030 --> 00:37:39,760
there's only one that each term has at

726
00:37:39,760 --> 00:37:43,150
most one leader so yeah so voted for the

727
00:37:43,150 --> 00:37:45,910
specific you know potential damaging

728
00:37:45,910 --> 00:37:48,339
case is that if a server receives a boat

729
00:37:48,339 --> 00:37:50,800
request and votes for server one and

730
00:37:50,800 --> 00:37:53,260
then it crashes and if it didn't persist

731
00:37:53,260 --> 00:37:55,720
this the identity of who had voted for

732
00:37:55,720 --> 00:37:58,000
and in my crash we start get another

733
00:37:58,000 --> 00:37:59,920
boat request for the same term from

734
00:37:59,920 --> 00:38:01,839
server two and say gosh I haven't voted

735
00:38:01,839 --> 00:38:03,550
for anybody because my voted for is

736
00:38:03,550 --> 00:38:03,940
blank

737
00:38:03,940 --> 00:38:05,859
now I'm gonna vote for server 2 and now

738
00:38:05,859 --> 00:38:08,349
our servers voted for server 1 and for

739
00:38:08,349 --> 00:38:12,160
server 2 in the same term and that might

740
00:38:12,160 --> 00:38:14,290
allow two servers

741
00:38:14,290 --> 00:38:16,000
since both server and server to voted

742
00:38:16,000 --> 00:38:17,980
for themselves they both may think they

743
00:38:17,980 --> 00:38:19,210
have a majority out of three and they're

744
00:38:19,210 --> 00:38:20,440
both going to become leader now we have

745
00:38:20,440 --> 00:38:23,349
two simultaneous servers for the same

746
00:38:23,349 --> 00:38:24,910
term so this that's why I voted for it

747
00:38:24,910 --> 00:38:28,569
has to be persistent current term is

748
00:38:28,569 --> 00:38:30,700
gonna be a little more subtle but we

749
00:38:30,700 --> 00:38:34,510
actually talked before about how you

750
00:38:34,510 --> 00:38:36,400
know again we don't want to have more

751
00:38:36,400 --> 00:38:38,470
than one server for a term and if we

752
00:38:38,470 --> 00:38:41,220
don't know what term number it is then

753
00:38:41,220 --> 00:38:44,500
we can't necessarily then it may be hard

754
00:38:44,500 --> 00:38:46,780
to ensure that there's only one server

755
00:38:46,780 --> 00:38:49,780
for a term and I think maybe in this

756
00:38:49,780 --> 00:38:54,099
example ya if s if server 1 was down and

757
00:38:54,099 --> 00:38:57,190
server 2 and server 3 we're gonna try to

758
00:38:57,190 --> 00:38:59,680
elect a new server they need evidence

759
00:38:59,680 --> 00:39:02,140
that the correct turn numbers 8 and not

760
00:39:02,140 --> 00:39:04,990
6 right because if they if they forgot

761
00:39:04,990 --> 00:39:06,670
about current term and it was just

762
00:39:06,670 --> 00:39:08,319
server 2 and server 3 voting for each

763
00:39:08,319 --> 00:39:09,550
other and they only had their log to

764
00:39:09,550 --> 00:39:10,990
look at they might think the next term

765
00:39:10,990 --> 00:39:12,849
should be term 6 they did that they

766
00:39:12,849 --> 00:39:14,680
start producing stuff for term 6 but now

767
00:39:14,680 --> 00:39:16,119
there's gonna be a lot of confusion

768
00:39:16,119 --> 00:39:18,720
because we have two different term sixes

769
00:39:18,720 --> 00:39:21,720
and so that's the reason my current term

770
00:39:21,720 --> 00:39:24,819
has to be persistent to preserve

771
00:39:24,819 --> 00:39:27,579
evidence about term numbers that have

772
00:39:27,579 --> 00:39:34,410
already been used these have to be

773
00:39:34,410 --> 00:39:38,440
persisted pretty much every time you

774
00:39:38,440 --> 00:39:42,640
change them right so certainly the safe

775
00:39:42,640 --> 00:39:44,170
thing to do is every time you add an

776
00:39:44,170 --> 00:39:46,900
entry of log or change current term

777
00:39:46,900 --> 00:39:51,190
are said voted for you need you probably

778
00:39:51,190 --> 00:39:53,320
need to persist that and in a real raft

779
00:39:53,320 --> 00:39:54,520
server that would mean writing it to the

780
00:39:54,520 --> 00:39:56,320
disk so you'd have some set of files

781
00:39:56,320 --> 00:39:59,230
that recorded this stuff you can

782
00:39:59,230 --> 00:40:01,990
probably be a little bit you may be can

783
00:40:01,990 --> 00:40:04,619
cut some corners if you observed that

784
00:40:04,619 --> 00:40:08,140
you don't need to persist these things

785
00:40:08,140 --> 00:40:09,730
until you communicate with the outside

786
00:40:09,730 --> 00:40:11,890
world so there may be some opportunity

787
00:40:11,890 --> 00:40:13,210
for a little bit of batching by saying

788
00:40:13,210 --> 00:40:14,500
well we don't have to persist anything

789
00:40:14,500 --> 00:40:17,230
until we're about to reply to an RPC or

790
00:40:17,230 --> 00:40:20,740
about to send out an RPC I mean that may

791
00:40:20,740 --> 00:40:23,220
allow you to avoid a few persisting x'

792
00:40:23,220 --> 00:40:27,060
the reason that's important is that

793
00:40:27,060 --> 00:40:31,180
writing stuff to disk is can be very

794
00:40:31,180 --> 00:40:32,619
expensive it's a if it's a mechanical

795
00:40:32,619 --> 00:40:34,330
hard drive that we're talking about then

796
00:40:34,330 --> 00:40:37,030
writing anything you know if the way

797
00:40:37,030 --> 00:40:38,650
we're persisting is writing files on the

798
00:40:38,650 --> 00:40:41,380
disk writing anything on the disk cost

799
00:40:41,380 --> 00:40:43,030
you about 10 milliseconds because you

800
00:40:43,030 --> 00:40:45,270
either have to wait for the disk to spin

801
00:40:45,270 --> 00:40:47,560
for the point you want to write to spin

802
00:40:47,560 --> 00:40:49,900
under the head which disk only rotates

803
00:40:49,900 --> 00:40:51,849
about once every 10 milliseconds or

804
00:40:51,849 --> 00:40:53,140
worse that you may actually have to seek

805
00:40:53,140 --> 00:40:55,690
to move the arm the right track right so

806
00:40:55,690 --> 00:40:58,570
these per systems can be terribly

807
00:40:58,570 --> 00:41:01,510
terribly expensive and if for sort of

808
00:41:01,510 --> 00:41:03,520
any kind of straightforward design

809
00:41:03,520 --> 00:41:06,220
they're likely to be the limiting factor

810
00:41:06,220 --> 00:41:09,089
in performance because they mean that

811
00:41:09,089 --> 00:41:13,690
doing anything anything whatsoever on

812
00:41:13,690 --> 00:41:15,339
these graph servers takes ten

813
00:41:15,339 --> 00:41:18,580
milliseconds a pop and 10 milliseconds

814
00:41:18,580 --> 00:41:20,410
as far longer than it takes to say send

815
00:41:20,410 --> 00:41:23,320
an RPC or almost anything else you might

816
00:41:23,320 --> 00:41:26,170
do 10 milliseconds each means you can

817
00:41:26,170 --> 00:41:29,609
just never if you persist data to a

818
00:41:29,609 --> 00:41:31,869
mechanical drive you just can never

819
00:41:31,869 --> 00:41:33,400
build a raft service it can serve more

820
00:41:33,400 --> 00:41:37,330
than 100 requests per second because

821
00:41:37,330 --> 00:41:38,530
that's what you get it at 10

822
00:41:38,530 --> 00:41:41,619
milliseconds per operation and you know

823
00:41:41,619 --> 00:41:44,770
this is this cost so this is really all

824
00:41:44,770 --> 00:41:48,420
about cost of synchronous

825
00:41:49,920 --> 00:41:58,090
just updates and it comes up in many

826
00:41:58,090 --> 00:41:59,530
systems like file systems the file

827
00:41:59,530 --> 00:42:00,970
systems that are running in your laptops

828
00:42:00,970 --> 00:42:03,280
are that the designers spend a huge

829
00:42:03,280 --> 00:42:05,170
amount of time sort of trying to

830
00:42:05,170 --> 00:42:07,120
navigate around the performance problems

831
00:42:07,120 --> 00:42:09,040
of synchronous disk up they think of as

832
00:42:09,040 --> 00:42:10,960
disk writes because in order for stuff

833
00:42:10,960 --> 00:42:12,370
to get safe on your disk in order to

834
00:42:12,370 --> 00:42:14,200
update the file system on your laptop's

835
00:42:14,200 --> 00:42:18,430
disk safely there turns out the file

836
00:42:18,430 --> 00:42:20,620
system has to like be careful about how

837
00:42:20,620 --> 00:42:22,840
it writes and needs to sometimes wait

838
00:42:22,840 --> 00:42:25,420
for the disk to finish writing so this

839
00:42:25,420 --> 00:42:27,880
is a like a cross-cutting issue in all

840
00:42:27,880 --> 00:42:29,740
kinds of systems certainly comes up in

841
00:42:29,740 --> 00:42:33,700
draft if you want it to build a system

842
00:42:33,700 --> 00:42:34,900
they could serve more than a hundred

843
00:42:34,900 --> 00:42:38,830
quests per second then there's a bunch

844
00:42:38,830 --> 00:42:39,940
of options one is you can use a

845
00:42:39,940 --> 00:42:41,770
solid-state drive or some kind of flash

846
00:42:41,770 --> 00:42:44,320
or something solid eight drives can do a

847
00:42:44,320 --> 00:42:50,530
write to the flash memory in maybe a

848
00:42:50,530 --> 00:42:52,600
tenth of a millisecond so that's a

849
00:42:52,600 --> 00:42:55,480
factor of a hundred for you or if you're

850
00:42:55,480 --> 00:42:57,730
even more sophisticated maybe you can

851
00:42:57,730 --> 00:43:02,200
build yourself battery backed DRAM and

852
00:43:02,200 --> 00:43:03,820
do the persistence into battery back

853
00:43:03,820 --> 00:43:07,270
DRAM and then if the server reboots hope

854
00:43:07,270 --> 00:43:11,020
that reboot was took shorter than the

855
00:43:11,020 --> 00:43:12,430
amount of time the battery lasts and

856
00:43:12,430 --> 00:43:14,560
that this stuff you persisted is still

857
00:43:14,560 --> 00:43:17,770
in the RAM and the reason I mean if you

858
00:43:17,770 --> 00:43:19,420
have money and sophistication the reason

859
00:43:19,420 --> 00:43:21,400
to favor that is you can write DRAM you

860
00:43:21,400 --> 00:43:23,230
know millions of times per second and so

861
00:43:23,230 --> 00:43:24,600
it's probably not going to be a

862
00:43:24,600 --> 00:43:28,600
performance bottleneck anyway so that

863
00:43:28,600 --> 00:43:33,370
this problem is why and it's sort of

864
00:43:33,370 --> 00:43:35,230
marking a persistent versus volatile and

865
00:43:35,230 --> 00:43:36,880
figure 2 is like has a lot of

866
00:43:36,880 --> 00:43:38,910
significance for performance as well as

867
00:43:38,910 --> 00:43:43,690
crash recovery and correctness any

868
00:43:43,690 --> 00:43:48,300
questions about persisting yeah

869
00:43:55,570 --> 00:44:08,240
yes alright so your question is

870
00:44:08,240 --> 00:44:10,340
basically you're writing code say go

871
00:44:10,340 --> 00:44:12,410
code for your raft implementation or

872
00:44:12,410 --> 00:44:13,520
you're trying to write a real rafterman

873
00:44:13,520 --> 00:44:15,200
implementation and you actually want to

874
00:44:15,200 --> 00:44:18,500
make sure that when you persist your an

875
00:44:18,500 --> 00:44:20,180
update to the law or the current term or

876
00:44:20,180 --> 00:44:21,800
whatever that it in fact will be there

877
00:44:21,800 --> 00:44:23,870
after a crash and reboot like what's the

878
00:44:23,870 --> 00:44:26,300
recipe for what you have to do to make

879
00:44:26,300 --> 00:44:28,010
sure it's there and your observation

880
00:44:28,010 --> 00:44:31,040
that if you call you know on a UNIX or

881
00:44:31,040 --> 00:44:34,450
Linux or whatever Mac if you call right

882
00:44:34,450 --> 00:44:36,980
you know the right system call is how

883
00:44:36,980 --> 00:44:38,510
you write to a disk file you simply call

884
00:44:38,510 --> 00:44:41,330
right as you pointed out it is not the

885
00:44:41,330 --> 00:44:43,670
case that after the write returns the

886
00:44:43,670 --> 00:44:45,800
data is safe on disk and will survive a

887
00:44:45,800 --> 00:44:48,650
reboot it almost certainly isn't almost

888
00:44:48,650 --> 00:44:51,200
certainly not on disk so the you know

889
00:44:51,200 --> 00:44:53,480
the particular piece of magic you need

890
00:44:53,480 --> 00:44:56,210
to do is on unix at any rate you need

891
00:44:56,210 --> 00:44:58,510
you need to call right so you cannot

892
00:44:58,510 --> 00:45:01,340
write some file you've opened that's

893
00:45:01,340 --> 00:45:02,720
going to contain the stuff that you want

894
00:45:02,720 --> 00:45:06,290
to write and then you got a call this F

895
00:45:06,290 --> 00:45:09,710
st. call which on most systems the

896
00:45:09,710 --> 00:45:12,010
guarantee is that F sync doesn't return

897
00:45:12,010 --> 00:45:15,350
until all the data you've previously

898
00:45:15,350 --> 00:45:18,140
written into this file is safely on the

899
00:45:18,140 --> 00:45:22,130
surface on the media in a place on a

900
00:45:22,130 --> 00:45:23,780
place where it will still be there if

901
00:45:23,780 --> 00:45:26,930
there's a crash so so this thing is some

902
00:45:26,930 --> 00:45:29,030
then this call is an expensive call and

903
00:45:29,030 --> 00:45:30,620
that's why it's a separate that's why

904
00:45:30,620 --> 00:45:33,500
Wright doesn't write the disk only F

905
00:45:33,500 --> 00:45:35,420
sync does is because it's so expensive

906
00:45:35,420 --> 00:45:37,010
you would never want to do it unless you

907
00:45:37,010 --> 00:45:40,460
really wanted to persist some stuff some

908
00:45:40,460 --> 00:45:46,280
data okay so you can use more expensive

909
00:45:46,280 --> 00:45:47,930
disk hardware the other trick people

910
00:45:47,930 --> 00:45:51,410
play a lot is to try to batch that is if

911
00:45:51,410 --> 00:45:53,810
you can if client requests are if you

912
00:45:53,810 --> 00:45:55,370
have a lot of client requests coming in

913
00:45:55,370 --> 00:45:57,410
maybe you should accept a lot of them

914
00:45:57,410 --> 00:45:59,210
and not reply to any of them for a

915
00:45:59,210 --> 00:46:00,860
little bit we call a lot of them

916
00:46:00,860 --> 00:46:01,640
accumulate

917
00:46:01,640 --> 00:46:05,000
and then persist you know a hundred log

918
00:46:05,000 --> 00:46:07,610
entries at a time from your hundred

919
00:46:07,610 --> 00:46:09,800
clients and you know only then send out

920
00:46:09,800 --> 00:46:12,320
the append entries good because you do

921
00:46:12,320 --> 00:46:13,550
actually have to persist this stuff to

922
00:46:13,550 --> 00:46:16,130
disk if you receive a client request you

923
00:46:16,130 --> 00:46:17,600
have to persist the new entry to disk

924
00:46:17,600 --> 00:46:20,330
before you send the append entries our

925
00:46:20,330 --> 00:46:24,920
PCs the followers because you're not

926
00:46:24,920 --> 00:46:26,690
allowed if the leader you know the

927
00:46:26,690 --> 00:46:29,420
leader it's essentially promising to

928
00:46:29,420 --> 00:46:34,400
commit that that request and can't

929
00:46:34,400 --> 00:46:35,150
forget about it

930
00:46:35,150 --> 00:46:37,490
and indeed the followers have to persist

931
00:46:37,490 --> 00:46:39,260
the new log entry to their disk before

932
00:46:39,260 --> 00:46:40,880
they reply to the append entries because

933
00:46:40,880 --> 00:46:42,170
they were apply to the append entries

934
00:46:42,170 --> 00:46:45,110
it's also a promise to preserve and

935
00:46:45,110 --> 00:46:46,970
eventually commit that log entry so they

936
00:46:46,970 --> 00:46:48,620
can't be allowed to forget about it if

937
00:46:48,620 --> 00:46:51,950
they crash other questions about

938
00:46:51,950 --> 00:47:01,430
persistence all right well final you

939
00:47:01,430 --> 00:47:02,780
know a little detail about persistence

940
00:47:02,780 --> 00:47:09,620
is that some of the stuff in figure two

941
00:47:09,620 --> 00:47:11,300
is not persistent and so it's worth

942
00:47:11,300 --> 00:47:12,770
scratching your head a little bit about

943
00:47:12,770 --> 00:47:15,290
why commit index lasts apply next index

944
00:47:15,290 --> 00:47:17,240
and match index why it's fair game for

945
00:47:17,240 --> 00:47:19,640
them to be simply thrown away if the

946
00:47:19,640 --> 00:47:22,010
server crashes and restarts like why

947
00:47:22,010 --> 00:47:24,860
wasn't you know commit index or last

948
00:47:24,860 --> 00:47:26,510
apply it like geez last applied is the

949
00:47:26,510 --> 00:47:29,360
record of how much we've executed right

950
00:47:29,360 --> 00:47:30,440
if we throw that away aren't we gonna

951
00:47:30,440 --> 00:47:32,180
execute log entries twice and is that

952
00:47:32,180 --> 00:47:35,690
correct how about that why is why is it

953
00:47:35,690 --> 00:47:39,310
safe to throw away last applied

954
00:47:46,680 --> 00:47:55,630
yes I am we're all about simplicity and

955
00:47:55,630 --> 00:47:58,150
safety here with raft so that's exactly

956
00:47:58,150 --> 00:48:02,320
correct the the reason why all that

957
00:48:02,320 --> 00:48:04,240
other stuff can be non-volatile as you

958
00:48:04,240 --> 00:48:06,880
mentioned I mean sorry volatile the

959
00:48:06,880 --> 00:48:07,930
reason why those other fields can be

960
00:48:07,930 --> 00:48:10,360
volatile and thrown away is that we can

961
00:48:10,360 --> 00:48:12,580
the leader can reconstruct sort of

962
00:48:12,580 --> 00:48:15,340
what's been committed by inspecting its

963
00:48:15,340 --> 00:48:17,650
own log and by the results of append

964
00:48:17,650 --> 00:48:19,090
entries that it sends out to the

965
00:48:19,090 --> 00:48:20,680
followers I mean initially the leader if

966
00:48:20,680 --> 00:48:22,300
it if everybody restarts because they

967
00:48:22,300 --> 00:48:23,320
experienced a power failure

968
00:48:23,320 --> 00:48:24,940
initially the leader does not know

969
00:48:24,940 --> 00:48:27,880
what's committed what's executed but

970
00:48:27,880 --> 00:48:29,680
when it sends out log and append entries

971
00:48:29,680 --> 00:48:31,210
it'll sort of gather back information

972
00:48:31,210 --> 00:48:32,770
and essentially from the followers about

973
00:48:32,770 --> 00:48:34,780
What's in how much of their logs match

974
00:48:34,780 --> 00:48:36,370
the leaders and therefore how much must

975
00:48:36,370 --> 00:48:38,070
have been committed before the crash

976
00:48:38,070 --> 00:48:41,950
another thing in the 4-2 world which is

977
00:48:41,950 --> 00:48:43,150
not the real world

978
00:48:43,150 --> 00:48:45,130
another thing about figure two is that

979
00:48:45,130 --> 00:48:47,770
figure two assumes that the application

980
00:48:47,770 --> 00:48:51,580
state is destroyed and thrown away if

981
00:48:51,580 --> 00:48:54,310
there's a crash in a restart so the

982
00:48:54,310 --> 00:48:55,900
figure two world assumes that while log

983
00:48:55,900 --> 00:48:57,550
is persistent that the application state

984
00:48:57,550 --> 00:49:00,100
is absolutely not persistent required

985
00:49:00,100 --> 00:49:04,200
not to be consistent in figure 2 because

986
00:49:04,200 --> 00:49:07,390
the in figure 2 the log is preserved

987
00:49:07,390 --> 00:49:10,030
persisted from the very beginning of the

988
00:49:10,030 --> 00:49:13,000
system and so what's going to happen if

989
00:49:13,000 --> 00:49:15,640
you sort of play out what the various

990
00:49:15,640 --> 00:49:18,460
rules in figure 2 after a leader restart

991
00:49:18,460 --> 00:49:21,130
is that the leader will eventually re

992
00:49:21,130 --> 00:49:24,010
execute every single log entry that is

993
00:49:24,010 --> 00:49:26,500
handed to the application you know

994
00:49:26,500 --> 00:49:28,600
starting with log entry one after a

995
00:49:28,600 --> 00:49:31,420
reboot it's the raft is gonna hand the

996
00:49:31,420 --> 00:49:33,340
application every log entry starting

997
00:49:33,340 --> 00:49:34,840
from one and so that will after a

998
00:49:34,840 --> 00:49:36,790
restart the application will completely

999
00:49:36,790 --> 00:49:39,640
reconstruct its state from scratch by a

1000
00:49:39,640 --> 00:49:41,890
replay from the beginning of the time of

1001
00:49:41,890 --> 00:49:45,430
the entire log after each restart and

1002
00:49:45,430 --> 00:49:46,360
again that's like a sort of

1003
00:49:46,360 --> 00:49:49,390
straightforward elegant plan but

1004
00:49:49,390 --> 00:49:55,290
obviously potentially very slow

1005
00:49:56,119 --> 00:49:58,040
which brings us to the next topic which

1006
00:49:58,040 --> 00:50:04,670
is log compaction and and snapshots and

1007
00:50:04,670 --> 00:50:07,970
this has a lot to do with lab 3b

1008
00:50:07,970 --> 00:50:09,619
actually you'll see log compaction and

1009
00:50:09,619 --> 00:50:13,970
snapshots in vlog 3b in lab 3b and so

1010
00:50:13,970 --> 00:50:15,440
the problem that log compaction and

1011
00:50:15,440 --> 00:50:18,800
snapshotting is solving a raft is that

1012
00:50:18,800 --> 00:50:20,690
indeed for a long-running system that's

1013
00:50:20,690 --> 00:50:22,359
been going for weeks or months or years

1014
00:50:22,359 --> 00:50:25,310
if we just follow the figure 2 rules the

1015
00:50:25,310 --> 00:50:27,410
log just keeps on growing may end up you

1016
00:50:27,410 --> 00:50:28,490
know millions and millions of entries

1017
00:50:28,490 --> 00:50:30,770
long and so requires a lot of memory to

1018
00:50:30,770 --> 00:50:34,130
store if you store it on disk like if

1019
00:50:34,130 --> 00:50:35,359
you have to persist it every time you

1020
00:50:35,359 --> 00:50:37,130
persist the log it's using up a huge I

1021
00:50:37,130 --> 00:50:39,200
may not space on disk and if a server

1022
00:50:39,200 --> 00:50:41,990
ever be starts it has to reconstruct its

1023
00:50:41,990 --> 00:50:44,660
state by replaying these millions and

1024
00:50:44,660 --> 00:50:46,040
millions of log entries from the very

1025
00:50:46,040 --> 00:50:47,660
beginning which could take like hours

1026
00:50:47,660 --> 00:50:50,030
for a server to run through its entire

1027
00:50:50,030 --> 00:50:52,790
log and we execute it if it crashes and

1028
00:50:52,790 --> 00:50:54,680
restarts all of which is like similar

1029
00:50:54,680 --> 00:50:56,480
what kind of wasted because before it

1030
00:50:56,480 --> 00:50:58,670
crashed it had already had applications

1031
00:50:58,670 --> 00:51:08,230
state and so in order to cope with this

1032
00:51:08,230 --> 00:51:11,750
wrath has this idea of snapshots and the

1033
00:51:11,750 --> 00:51:15,230
sort of idea behind snapshots is to be

1034
00:51:15,230 --> 00:51:18,410
able to save or ask the application to

1035
00:51:18,410 --> 00:51:20,839
save a copy of its state as of a

1036
00:51:20,839 --> 00:51:23,270
particular log entry so we've been

1037
00:51:23,270 --> 00:51:24,920
mostly kind of ignoring the application

1038
00:51:24,920 --> 00:51:28,160
but the fact is that you know if we have

1039
00:51:28,160 --> 00:51:30,140
a suppose we're building a key value

1040
00:51:30,140 --> 00:51:33,349
store under BRAF you know the log is

1041
00:51:33,349 --> 00:51:34,940
gonna contain a bunch of you know

1042
00:51:34,940 --> 00:51:37,099
putting gets or read and write request

1043
00:51:37,099 --> 00:51:39,680
so maybe a law contains you know a put

1044
00:51:39,680 --> 00:51:42,410
that some client wants to set X to one

1045
00:51:42,410 --> 00:51:44,359
and then another one where it says X to

1046
00:51:44,359 --> 00:51:47,690
2 and then you know y equals 7 or

1047
00:51:47,690 --> 00:51:51,050
whatever and if there's no crashes as

1048
00:51:51,050 --> 00:51:53,569
the raft is executing along there's

1049
00:51:53,569 --> 00:51:55,730
going to be this if the layer above Rath

1050
00:51:55,730 --> 00:51:57,260
there's going to be this application and

1051
00:51:57,260 --> 00:51:59,390
the application if it's a key value

1052
00:51:59,390 --> 00:52:01,520
store databases it's going to be meeting

1053
00:52:01,520 --> 00:52:05,420
this table and as raft hands it one

1054
00:52:05,420 --> 00:52:07,220
command after our next

1055
00:52:07,220 --> 00:52:09,140
the applications going to update its

1056
00:52:09,140 --> 00:52:10,880
table so you know after the first

1057
00:52:10,880 --> 00:52:12,890
command it's going to set X to one and

1058
00:52:12,890 --> 00:52:14,300
it's stable after the second command

1059
00:52:14,300 --> 00:52:18,400
it's going to update its table you know

1060
00:52:19,630 --> 00:52:22,040
one interesting fact is that for most

1061
00:52:22,040 --> 00:52:24,320
applications the application state is

1062
00:52:24,320 --> 00:52:26,990
likely to be much smaller than the

1063
00:52:26,990 --> 00:52:29,840
corresponding log right at some level we

1064
00:52:29,840 --> 00:52:31,550
know that the the you know the log and

1065
00:52:31,550 --> 00:52:33,710
the state are the log in that and the

1066
00:52:33,710 --> 00:52:35,150
state as of some point in the log are

1067
00:52:35,150 --> 00:52:38,320
kind of interchangeable right they both

1068
00:52:38,320 --> 00:52:40,820
sort of implied the same thing about the

1069
00:52:40,820 --> 00:52:44,570
state of the application but the log may

1070
00:52:44,570 --> 00:52:46,100
contain a lot of you know a lot of

1071
00:52:46,100 --> 00:52:48,170
multiple assignments 2x they use up a

1072
00:52:48,170 --> 00:52:49,850
lot of space in the log but are also to

1073
00:52:49,850 --> 00:52:51,860
effectively compact it down to a single

1074
00:52:51,860 --> 00:52:53,510
entry in the table and that's pretty

1075
00:52:53,510 --> 00:52:56,300
typical of these replicated applications

1076
00:52:56,300 --> 00:53:00,110
but the point is that instead of storing

1077
00:53:00,110 --> 00:53:02,690
the log which may go to be huge we have

1078
00:53:02,690 --> 00:53:05,330
the option of storing instead the table

1079
00:53:05,330 --> 00:53:08,060
which might be a lot smaller and that's

1080
00:53:08,060 --> 00:53:11,630
what the snapshots are doing so when

1081
00:53:11,630 --> 00:53:14,420
raft feels that it's log has gotten to

1082
00:53:14,420 --> 00:53:17,690
be too large you know more than a

1083
00:53:17,690 --> 00:53:19,190
megabyte or ten megabytes or whatever

1084
00:53:19,190 --> 00:53:21,620
some arbitrary limit raft will ask the

1085
00:53:21,620 --> 00:53:24,260
application to take make a snapshot of

1086
00:53:24,260 --> 00:53:26,990
it the application state as of a certain

1087
00:53:26,990 --> 00:53:28,370
point in the log

1088
00:53:28,370 --> 00:53:30,760
so if we add if raft asked the

1089
00:53:30,760 --> 00:53:33,110
application for a snapshot reference it

1090
00:53:33,110 --> 00:53:35,300
would pick a point in the log that the

1091
00:53:35,300 --> 00:53:37,370
snapshot referred to and require the

1092
00:53:37,370 --> 00:53:39,770
application to produce a snapshot as at

1093
00:53:39,770 --> 00:53:41,570
that point this is extremely critical

1094
00:53:41,570 --> 00:53:44,480
because the because what we're about to

1095
00:53:44,480 --> 00:53:45,980
do is throw away everything before that

1096
00:53:45,980 --> 00:53:47,360
point so if there's not a will to find

1097
00:53:47,360 --> 00:53:48,860
point that corresponds to a snapshot

1098
00:53:48,860 --> 00:53:51,290
then we can't safely throw away the log

1099
00:53:51,290 --> 00:53:54,910
before that point so that means that

1100
00:53:54,910 --> 00:53:57,020
Rath is gonna have you know ask for

1101
00:53:57,020 --> 00:53:58,340
snaps on the snap so it's basically just

1102
00:53:58,340 --> 00:54:00,650
the table it's just about a database

1103
00:54:00,650 --> 00:54:04,520
server and we also need to annotate the

1104
00:54:04,520 --> 00:54:07,400
snapshot with the entry number that are

1105
00:54:07,400 --> 00:54:09,890
corresponds to you so it's basically you

1106
00:54:09,890 --> 00:54:12,380
know if the entries are 1 2 3 this

1107
00:54:12,380 --> 00:54:16,400
snapshot corresponds to just after log

1108
00:54:16,400 --> 00:54:19,809
index 3 with the snapshot in hand

1109
00:54:19,809 --> 00:54:23,329
if we persist it to disk rats persistent

1110
00:54:23,329 --> 00:54:26,869
to disk raft never again will need this

1111
00:54:26,869 --> 00:54:33,890
part of the logs and it can simply throw

1112
00:54:33,890 --> 00:54:36,650
it away as long as it persists a

1113
00:54:36,650 --> 00:54:39,589
snapshot as of a certain in debt log

1114
00:54:39,589 --> 00:54:42,710
index plus the log after that index as

1115
00:54:42,710 --> 00:54:44,450
long as that's persisted to disk we

1116
00:54:44,450 --> 00:54:46,480
never going to need to log before that

1117
00:54:46,480 --> 00:54:49,789
and so this is what RAF does the rocks

1118
00:54:49,789 --> 00:54:51,529
ask the application for snapshot gets

1119
00:54:51,529 --> 00:54:52,970
the snapshot saves it to disk with the

1120
00:54:52,970 --> 00:54:54,470
log after that it just throws away this

1121
00:54:54,470 --> 00:54:58,369
log here right and so it really operates

1122
00:54:58,369 --> 00:55:00,950
or the sort of persistence story is all

1123
00:55:00,950 --> 00:55:03,529
about pairs of a snapshot in the log

1124
00:55:03,529 --> 00:55:06,230
after that after the point in the log

1125
00:55:06,230 --> 00:55:09,890
associated with snapshot I don't see

1126
00:55:09,890 --> 00:55:12,700
this yes

1127
00:55:24,309 --> 00:55:27,680
no it's still it's it's you know there's

1128
00:55:27,680 --> 00:55:29,270
these sort of phantom entries one two

1129
00:55:29,270 --> 00:55:31,430
three and this you know suffix of the

1130
00:55:31,430 --> 00:55:37,390
log is indeed viewed as still the it's

1131
00:55:37,390 --> 00:55:39,230
maybe the right way to think of it is

1132
00:55:39,230 --> 00:55:41,240
still there's just one log except these

1133
00:55:41,240 --> 00:55:43,510
entries are sort of phantom entries that

1134
00:55:43,510 --> 00:55:46,579
we that we can view as being kind of

1135
00:55:46,579 --> 00:55:48,770
there in principle but since we're we

1136
00:55:48,770 --> 00:55:51,020
never need to look at them because we

1137
00:55:51,020 --> 00:55:52,549
have the snapshot the fact that they

1138
00:55:52,549 --> 00:55:53,869
just happened not to be stored anywhere

1139
00:55:53,869 --> 00:55:57,829
is neither here nor there but it's but

1140
00:55:57,829 --> 00:55:58,700
yeah you should think of it as being

1141
00:55:58,700 --> 00:56:01,640
stole the same log it's just not just

1142
00:56:01,640 --> 00:56:04,819
threw away their early entries did this

1143
00:56:04,819 --> 00:56:06,440
that's a maybe a little bit too glib of

1144
00:56:06,440 --> 00:56:07,579
an answer because the fact is that

1145
00:56:07,579 --> 00:56:10,130
figure two talks about the log in ways

1146
00:56:10,130 --> 00:56:12,559
that makes it that if you just follow

1147
00:56:12,559 --> 00:56:14,240
figure to you sometimes still need these

1148
00:56:14,240 --> 00:56:15,799
earlier entries and so you'll have to

1149
00:56:15,799 --> 00:56:17,420
reinterpret figure two a little bit in

1150
00:56:17,420 --> 00:56:19,670
light of the fact that sometimes it says

1151
00:56:19,670 --> 00:56:22,309
blah blah blah a log entry where the log

1152
00:56:22,309 --> 00:56:32,680
entry doesn't exist okay

1153
00:56:39,390 --> 00:56:43,119
okay and so what happens on a restart

1154
00:56:43,119 --> 00:56:44,890
so the restart story is a little more

1155
00:56:44,890 --> 00:56:46,329
complicated in it than it used to be

1156
00:56:46,329 --> 00:56:48,700
with just a log what happens on a

1157
00:56:48,700 --> 00:56:50,289
restart is that there needs to be away

1158
00:56:50,289 --> 00:56:54,549
for raft to give the latest for graph to

1159
00:56:54,549 --> 00:56:56,980
find the latest snapshot log pair on its

1160
00:56:56,980 --> 00:57:01,059
disk and hand the snapshot to the

1161
00:57:01,059 --> 00:57:03,130
application because we no longer are

1162
00:57:03,130 --> 00:57:04,990
able to replay you know all the log

1163
00:57:04,990 --> 00:57:06,460
entries so there must be some other way

1164
00:57:06,460 --> 00:57:08,740
to initialize the application basically

1165
00:57:08,740 --> 00:57:10,240
not only is the application have to be

1166
00:57:10,240 --> 00:57:11,440
able to produce a snapshot of

1167
00:57:11,440 --> 00:57:13,930
application state but but it has to be

1168
00:57:13,930 --> 00:57:15,839
able to absorb a previously made

1169
00:57:15,839 --> 00:57:17,980
snapshot and sort of reconstruct it

1170
00:57:17,980 --> 00:57:20,740
stable in memory from a snapshot and so

1171
00:57:20,740 --> 00:57:22,240
this now even though raft is kind of

1172
00:57:22,240 --> 00:57:23,710
managing this whole snapshotting stuff

1173
00:57:23,710 --> 00:57:26,200
the snapshot contents are really the

1174
00:57:26,200 --> 00:57:28,299
property to the application and RAF

1175
00:57:28,299 --> 00:57:29,950
doesn't even understand what's in here

1176
00:57:29,950 --> 00:57:31,420
only the application does because it's

1177
00:57:31,420 --> 00:57:33,010
all full of application specific

1178
00:57:33,010 --> 00:57:36,279
information so after a restart the

1179
00:57:36,279 --> 00:57:39,789
application has to be able to absorb the

1180
00:57:39,789 --> 00:57:45,789
latest snapshot that raft found so for

1181
00:57:45,789 --> 00:57:48,750
just this simple it would be simple

1182
00:57:48,750 --> 00:57:52,089
unfortunately this snapshotting and in

1183
00:57:52,089 --> 00:57:54,579
particular the idea that the leader

1184
00:57:54,579 --> 00:57:56,920
might throw away part of its log

1185
00:57:56,920 --> 00:57:59,680
introduces a major piece of complexity

1186
00:57:59,680 --> 00:58:01,809
and that is that if there's some

1187
00:58:01,809 --> 00:58:05,940
follower out there whose log ends before

1188
00:58:05,940 --> 00:58:10,809
the point at which the leaders log

1189
00:58:10,809 --> 00:58:14,140
starts then unless we invent something

1190
00:58:14,140 --> 00:58:15,819
new we need monney install snapshot

1191
00:58:15,819 --> 00:58:17,920
unless we invent something new that

1192
00:58:17,920 --> 00:58:20,859
follower can never get up-to-date right

1193
00:58:20,859 --> 00:58:23,020
because if the followers you know if

1194
00:58:23,020 --> 00:58:25,210
there's some follower whose log only is

1195
00:58:25,210 --> 00:58:27,400
the first two log entries we no longer

1196
00:58:27,400 --> 00:58:29,890
have the log entry three that's required

1197
00:58:29,890 --> 00:58:32,710
to send it to that follower in an append

1198
00:58:32,710 --> 00:58:35,410
entries RPC to allow its log to catch up

1199
00:58:35,410 --> 00:58:41,150
to the leaders now

1200
00:58:41,150 --> 00:58:44,819
we could avoid this problem by having

1201
00:58:44,819 --> 00:58:47,880
the leader never drop part of its log if

1202
00:58:47,880 --> 00:58:50,430
there's any follower out there that

1203
00:58:50,430 --> 00:58:53,369
hasn't caught up to the point at which

1204
00:58:53,369 --> 00:58:54,960
the leader is thinking about doing a

1205
00:58:54,960 --> 00:58:56,490
snapshot because the leader knows

1206
00:58:56,490 --> 00:58:58,920
through next index

1207
00:58:58,920 --> 00:59:00,960
well actually leader doesn't really know

1208
00:59:00,960 --> 00:59:02,569
but the leader could know in principle

1209
00:59:02,569 --> 00:59:05,549
how far each follower had gotten and the

1210
00:59:05,549 --> 00:59:06,660
leader could say well I'm just never

1211
00:59:06,660 --> 00:59:09,299
gonna drop the part of my log before the

1212
00:59:09,299 --> 00:59:12,059
end of the follower with the shortest

1213
00:59:12,059 --> 00:59:16,890
log and that would be okay they might

1214
00:59:16,890 --> 00:59:20,039
actually just be a good idea period the

1215
00:59:20,039 --> 00:59:21,299
reason why that's maybe not such a great

1216
00:59:21,299 --> 00:59:23,039
idea is that of course if a follower

1217
00:59:23,039 --> 00:59:26,730
shut down for a week you know it's not

1218
00:59:26,730 --> 00:59:28,770
gonna be acknowledging log entries and

1219
00:59:28,770 --> 00:59:31,260
that means that the leader can't reduce

1220
00:59:31,260 --> 00:59:34,349
its memory use by snapshotting so the

1221
00:59:34,349 --> 00:59:36,000
way the raft designs chosen to go is

1222
00:59:36,000 --> 00:59:40,289
that the leader is allowed to throw away

1223
00:59:40,289 --> 00:59:42,059
parts of its logs that would be needed

1224
00:59:42,059 --> 00:59:43,619
by some follower and so we need some

1225
00:59:43,619 --> 00:59:45,770
other scheme that append entries to deal

1226
00:59:45,770 --> 00:59:48,029
with the gap between the end of some

1227
00:59:48,029 --> 00:59:49,349
followers log in the beginning of the

1228
00:59:49,349 --> 00:59:51,839
leaders log and so that solution is the

1229
00:59:51,839 --> 01:00:02,880
install snapshot RPC and the deal is

1230
01:00:02,880 --> 01:00:06,930
that when a leader we have some follower

1231
01:00:06,930 --> 01:00:09,480
whose log is that you know just powered

1232
01:00:09,480 --> 01:00:12,240
on its log as short the leaders gonna

1233
01:00:12,240 --> 01:00:14,549
send it and append entries and you know

1234
01:00:14,549 --> 01:00:15,869
it's gonna be forced the leaders gonna

1235
01:00:15,869 --> 01:00:17,250
be forced to backup and at some point

1236
01:00:17,250 --> 01:00:19,079
the leader you know failure or fail

1237
01:00:19,079 --> 01:00:20,819
dependent recalls will cause the leader

1238
01:00:20,819 --> 01:00:23,339
to realize it it's reached the beginning

1239
01:00:23,339 --> 01:00:25,140
of the actual log its doors and at that

1240
01:00:25,140 --> 01:00:27,150
point instead of sending in append

1241
01:00:27,150 --> 01:00:30,329
entries the leader will send its current

1242
01:00:30,329 --> 01:00:33,569
snapshot plus current law well send its

1243
01:00:33,569 --> 01:00:35,670
current snapshot to the follower and

1244
01:00:35,670 --> 01:00:37,890
then presumably immediately follow it

1245
01:00:37,890 --> 01:00:40,079
with an append entries that has the

1246
01:00:40,079 --> 01:00:43,190
leaders current law

1247
01:00:46,770 --> 01:00:49,770
questions

1248
01:00:52,369 --> 01:00:55,249
yeah I'm the sad truth this is like this

1249
01:00:55,249 --> 01:00:59,140
is adds significant complexity here

1250
01:00:59,140 --> 01:01:02,539
Jarrell I'm three partially because of

1251
01:01:02,539 --> 01:01:05,029
the kind of cooperation that's required

1252
01:01:05,029 --> 01:01:07,219
between raff this is sort of a little

1253
01:01:07,219 --> 01:01:08,779
bit of a violation of modularity it

1254
01:01:08,779 --> 01:01:12,049
requires a good deal cooperation like

1255
01:01:12,049 --> 01:01:13,579
for example when an install snapshot

1256
01:01:13,579 --> 01:01:15,979
comes in it's delivered to raft but raft

1257
01:01:15,979 --> 01:01:17,779
really requires the application to

1258
01:01:17,779 --> 01:01:23,239
absorb the snapshot so they have to talk

1259
01:01:23,239 --> 01:01:24,109
to each other more than they otherwise

1260
01:01:24,109 --> 01:01:33,619
might yes the question is that this is

1261
01:01:33,619 --> 01:01:35,210
the way the snapshot is created

1262
01:01:35,210 --> 01:01:36,890
dependent on the application

1263
01:01:36,890 --> 01:01:38,719
it's absolutely it so the snapshot

1264
01:01:38,719 --> 01:01:40,969
creation function is part of the

1265
01:01:40,969 --> 01:01:42,680
application as part of like the key

1266
01:01:42,680 --> 01:01:45,259
value server so raffle you know somehow

1267
01:01:45,259 --> 01:01:46,789
call up to the application and say geez

1268
01:01:46,789 --> 01:01:48,140
you know I really like a snapshot right

1269
01:01:48,140 --> 01:01:50,329
now in the application because only the

1270
01:01:50,329 --> 01:01:53,890
application understands what it's status

1271
01:01:53,890 --> 01:01:57,650
and you know the inverse function by

1272
01:01:57,650 --> 01:01:59,450
which an application reconstructs a

1273
01:01:59,450 --> 01:02:01,729
state from a snapshot files also totally

1274
01:02:01,729 --> 01:02:05,059
application dependent where there's

1275
01:02:05,059 --> 01:02:06,859
intertwining because of course every

1276
01:02:06,859 --> 01:02:09,499
snapshot has to be labeled with a point

1277
01:02:09,499 --> 01:02:12,789
in a log that it corresponds to

1278
01:02:25,270 --> 01:02:27,230
talking about rule six and figure

1279
01:02:27,230 --> 01:02:39,680
thirteen okay so yeah the question here

1280
01:02:39,680 --> 01:02:42,560
is that and you will be faced with this

1281
01:02:42,560 --> 01:02:46,250
in lab three that because the RPC system

1282
01:02:46,250 --> 01:02:48,650
isn't perfectly reliable and perfectly

1283
01:02:48,650 --> 01:02:50,900
sequenced and RBC's can arrive out of

1284
01:02:50,900 --> 01:02:52,640
order or not at all or you may send an

1285
01:02:52,640 --> 01:02:54,650
RPC and get no response and think it was

1286
01:02:54,650 --> 01:02:56,450
lost but actually was delivered and was

1287
01:02:56,450 --> 01:02:58,310
the reply that was lost all these things

1288
01:02:58,310 --> 01:03:02,540
happen including to send to whatever

1289
01:03:02,540 --> 01:03:04,610
install snapshot our pcs and the leaders

1290
01:03:04,610 --> 01:03:06,860
almost certainly sending out many our

1291
01:03:06,860 --> 01:03:08,750
pcs concurrently you know both append

1292
01:03:08,750 --> 01:03:12,200
entries and install snapshots that means

1293
01:03:12,200 --> 01:03:15,020
that you can get things like install

1294
01:03:15,020 --> 01:03:19,510
snapshot our pcs from deep in the past

1295
01:03:20,560 --> 01:03:25,040
almost anything else right and therefore

1296
01:03:25,040 --> 01:03:29,990
the the follower has to be careful you

1297
01:03:29,990 --> 01:03:31,220
know has to think carefully about an

1298
01:03:31,220 --> 01:03:35,650
install snapshot that arrives and the

1299
01:03:37,270 --> 01:03:39,440
yeah I think the specific thing you're

1300
01:03:39,440 --> 01:03:41,990
asking is that if follower receives that

1301
01:03:41,990 --> 01:03:43,790
an install snapshot that appears to be

1302
01:03:43,790 --> 01:03:46,310
completely redundant that is the install

1303
01:03:46,310 --> 01:03:47,780
snapshot contains information that's

1304
01:03:47,780 --> 01:03:50,390
older than the information the follower

1305
01:03:50,390 --> 01:03:51,440
already has

1306
01:03:51,440 --> 01:03:55,250
what should the follower do and rule six

1307
01:03:55,250 --> 01:03:57,350
and figure thirteen says something but I

1308
01:03:57,350 --> 01:03:59,480
think equally valid response to that is

1309
01:03:59,480 --> 01:04:01,340
that the follower can ignore a snapshot

1310
01:04:01,340 --> 01:04:07,460
that clearly is from the past I don't

1311
01:04:07,460 --> 01:04:12,070
really understand that rule six okay I

1312
01:04:12,070 --> 01:04:17,990
want to move on to sort of somewhat more

1313
01:04:17,990 --> 01:04:21,710
conceptual topic for a bit so far we

1314
01:04:21,710 --> 01:04:24,730
haven't really tried to nail down

1315
01:04:24,730 --> 01:04:27,020
anything about what it meant to be

1316
01:04:27,020 --> 01:04:28,610
correct

1317
01:04:28,610 --> 01:04:33,860
what I meant for a replicated service

1318
01:04:33,860 --> 01:04:36,290
already any other kind of service to be

1319
01:04:36,290 --> 01:04:39,050
behaving correctly and the reason why

1320
01:04:39,050 --> 01:04:42,320
and you know whatever for most of my

1321
01:04:42,320 --> 01:04:44,240
life I managed to get by without

1322
01:04:44,240 --> 01:04:46,070
worrying too much about precise

1323
01:04:46,070 --> 01:04:47,960
definitions of correctness but the fact

1324
01:04:47,960 --> 01:04:49,730
is that you know if you're trying to

1325
01:04:49,730 --> 01:04:51,380
optimize something or you're trying to

1326
01:04:51,380 --> 01:04:53,030
think through some weird corner case

1327
01:04:53,030 --> 01:04:55,820
it's often handy to actually have a more

1328
01:04:55,820 --> 01:04:58,100
or less formal way of deciding is that

1329
01:04:58,100 --> 01:05:00,470
behavior correct or not correct and so

1330
01:05:00,470 --> 01:05:01,910
you know for here what we're talking

1331
01:05:01,910 --> 01:05:03,680
about is you know clients are sending in

1332
01:05:03,680 --> 01:05:05,540
requests to the to our replicated

1333
01:05:05,540 --> 01:05:07,700
service with our PC maybe they'll be

1334
01:05:07,700 --> 01:05:09,710
sending who knows well maybe the service

1335
01:05:09,710 --> 01:05:11,840
is crash it can be starting and you know

1336
01:05:11,840 --> 01:05:14,210
loading snapshots or whatever the client

1337
01:05:14,210 --> 01:05:15,950
sends in a request and gets a response

1338
01:05:15,950 --> 01:05:18,320
like is that response correct how are we

1339
01:05:18,320 --> 01:05:20,090
supposed to how are we supposed to tell

1340
01:05:20,090 --> 01:05:22,430
whether response a would be correct or

1341
01:05:22,430 --> 01:05:26,210
response B so we need a notion we need a

1342
01:05:26,210 --> 01:05:27,740
pretty formal notion of distinguishing

1343
01:05:27,740 --> 01:05:30,050
oh that's okay from now that would be a

1344
01:05:30,050 --> 01:05:33,770
wrong answer and for this lab the our

1345
01:05:33,770 --> 01:05:36,230
notion of correctness is linearize

1346
01:05:36,230 --> 01:05:42,410
ability and I mentioned strong

1347
01:05:42,410 --> 01:05:43,910
consistency and some of the papers I

1348
01:05:43,910 --> 01:05:45,490
mentioned strong consistency and

1349
01:05:45,490 --> 01:05:47,270
basically equivalent to linearize

1350
01:05:47,270 --> 01:05:50,540
ability linearize ability is a sort of a

1351
01:05:50,540 --> 01:05:54,580
formalization of more or less of the

1352
01:05:54,580 --> 01:05:57,410
behavior you would expect if there was

1353
01:05:57,410 --> 01:05:59,720
just one server and it didn't crash and

1354
01:05:59,720 --> 01:06:02,210
it executed the command client requests

1355
01:06:02,210 --> 01:06:04,910
one at a time and you know nothing funny

1356
01:06:04,910 --> 01:06:09,170
ever happened so it has it has a

1357
01:06:09,170 --> 01:06:12,350
definition and the definition I'll write

1358
01:06:12,350 --> 01:06:14,110
out the definition then talk about it so

1359
01:06:14,110 --> 01:06:24,610
so an execution history is linearizable

1360
01:06:24,610 --> 01:06:30,830
linearizable and this is in the notes if

1361
01:06:30,830 --> 01:06:33,140
there exists a total order so an

1362
01:06:33,140 --> 01:06:34,910
execution history is a sequence of

1363
01:06:34,910 --> 01:06:37,220
client requests maybe many requests from

1364
01:06:37,220 --> 01:06:39,510
many clients

1365
01:06:39,510 --> 01:06:46,890
if there's some total order of the

1366
01:06:46,890 --> 01:06:53,640
operations in the history it matches the

1367
01:06:53,640 --> 01:06:55,560
real-time order of requests so if one

1368
01:06:55,560 --> 01:06:56,250
request

1369
01:06:56,250 --> 01:06:57,990
if client sends out a request and gets a

1370
01:06:57,990 --> 01:07:01,200
response and then later in time another

1371
01:07:01,200 --> 01:07:02,730
client sends out a request and I get a

1372
01:07:02,730 --> 01:07:04,890
response those two requests are ordered

1373
01:07:04,890 --> 01:07:07,770
because one of them's started after the

1374
01:07:07,770 --> 01:07:08,940
other one finished

1375
01:07:08,940 --> 01:07:12,300
so it's linearizable history is

1376
01:07:12,300 --> 01:07:13,860
linearizable if there exists an order of

1377
01:07:13,860 --> 01:07:15,900
the operations in the history that

1378
01:07:15,900 --> 01:07:23,250
matches real-time for non concurrent

1379
01:07:23,250 --> 01:07:25,860
requests that is for a request to didn't

1380
01:07:25,860 --> 01:07:42,270
overlap in time and each read you can

1381
01:07:42,270 --> 01:07:44,490
think of it as each read sees the value

1382
01:07:44,490 --> 01:07:46,740
from the most immediately preceding

1383
01:07:46,740 --> 01:07:56,760
right to the the same piece of data most

1384
01:07:56,760 --> 01:08:08,400
recent right in the order all right this

1385
01:08:08,400 --> 01:08:10,830
is the definition let me illustrate what

1386
01:08:10,830 --> 01:08:12,620
it means by running through an example

1387
01:08:12,620 --> 01:08:15,210
so first of all the history is a record

1388
01:08:15,210 --> 01:08:16,620
of client operations so this is a

1389
01:08:16,620 --> 01:08:18,510
definition that you can apply from

1390
01:08:18,510 --> 01:08:20,580
outside this definition doesn't appeal

1391
01:08:20,580 --> 01:08:23,430
in any way to what happens inside the

1392
01:08:23,430 --> 01:08:24,540
implementation or how the implementation

1393
01:08:24,540 --> 01:08:27,180
works it's something that we can if we

1394
01:08:27,180 --> 01:08:30,000
see a system operating and we can watch

1395
01:08:30,000 --> 01:08:32,460
the messages that come in and out we can

1396
01:08:32,460 --> 01:08:34,290
answer the question was that execution

1397
01:08:34,290 --> 01:08:42,410
that we observe linearizable so let me

1398
01:08:44,830 --> 01:08:47,600
let me write out of history and talk

1399
01:08:47,600 --> 01:08:51,160
about why it is or isn't linearizable

1400
01:08:53,529 --> 01:09:01,700
all right so here's an example the new

1401
01:09:01,700 --> 01:09:03,380
eyes ability talks about operations that

1402
01:09:03,380 --> 01:09:05,540
start at one point and end at another

1403
01:09:05,540 --> 01:09:07,250
and so this corresponds to the time at

1404
01:09:07,250 --> 01:09:10,279
which a client sends a request and then

1405
01:09:10,279 --> 01:09:13,970
later receives a reply so let us suppose

1406
01:09:13,970 --> 01:09:16,100
that our history says that at at some

1407
01:09:16,100 --> 01:09:19,189
particular time this time some client

1408
01:09:19,189 --> 01:09:22,160
sent a write request for the data item

1409
01:09:22,160 --> 01:09:24,580
named X and asked for it to be set to 1

1410
01:09:24,580 --> 01:09:28,670
and then time passed and at the second

1411
01:09:28,670 --> 01:09:30,170
vertical bar is when that client got a

1412
01:09:30,170 --> 01:09:31,910
reply through send a request at this

1413
01:09:31,910 --> 01:09:33,290
point you know time pass who knows

1414
01:09:33,290 --> 01:09:34,700
what's happening when the client got a

1415
01:09:34,700 --> 01:09:37,729
reply there and then later in time that

1416
01:09:37,729 --> 01:09:39,020
client or some other client doesn't

1417
01:09:39,020 --> 01:09:40,279
really matter

1418
01:09:40,279 --> 01:09:43,100
sends a write request again for item X

1419
01:09:43,100 --> 01:09:45,470
and value 2 and gets a response to that

1420
01:09:45,470 --> 01:09:52,370
right meanwhile some client sends a read

1421
01:09:52,370 --> 01:09:56,990
for X and gets value 2 and sent the

1422
01:09:56,990 --> 01:09:58,820
request there and got the response with

1423
01:09:58,820 --> 01:10:00,890
value 2 there and there's another

1424
01:10:00,890 --> 01:10:03,320
request that we observed it's a part of

1425
01:10:03,320 --> 01:10:07,280
the history request was sent to read

1426
01:10:07,280 --> 01:10:12,830
value X and it got value 1 back and so

1427
01:10:12,830 --> 01:10:14,750
when we have a history like this you

1428
01:10:14,750 --> 01:10:16,160
know the question were that you asked

1429
01:10:16,160 --> 01:10:17,690
about this history is is this a

1430
01:10:17,690 --> 01:10:20,180
linearizable history that is did the

1431
01:10:20,180 --> 01:10:22,310
machinery did the service did the system

1432
01:10:22,310 --> 01:10:23,930
that produced this history and was that

1433
01:10:23,930 --> 01:10:28,430
a linearizable system or did it produce

1434
01:10:28,430 --> 01:10:30,380
a linearizable history in this case if

1435
01:10:30,380 --> 01:10:31,790
this history is not linear inaudible

1436
01:10:31,790 --> 01:10:36,560
then then Lisa we're talking about I

1437
01:10:36,560 --> 01:10:38,750
have 3 we know we have a problem there

1438
01:10:38,750 --> 01:10:42,260
must be some some bug ok so we need to

1439
01:10:42,260 --> 01:10:43,460
analyze this to figure out if it's

1440
01:10:43,460 --> 01:10:45,980
linearizable there's linear linearize

1441
01:10:45,980 --> 01:10:48,830
ability requires us to produce an order

1442
01:10:48,830 --> 01:10:52,400
you know one by one order of the four

1443
01:10:52,400 --> 01:10:54,800
operations in that history so we know

1444
01:10:54,800 --> 01:10:55,850
we're looking for an order and there's

1445
01:10:55,850 --> 01:10:57,050
two constraints on the

1446
01:10:57,050 --> 01:11:03,890
order one is if one operation finished

1447
01:11:03,890 --> 01:11:07,640
before another started then the one that

1448
01:11:07,640 --> 01:11:08,900
finished first has to come first in the

1449
01:11:08,900 --> 01:11:13,790
history the other is if some read sees a

1450
01:11:13,790 --> 01:11:17,930
particular written value then the read

1451
01:11:17,930 --> 01:11:20,920
must come after the write in the order

1452
01:11:20,920 --> 01:11:23,090
all right so we want to order so we're

1453
01:11:23,090 --> 01:11:24,380
gonna produce an order that has four

1454
01:11:24,380 --> 01:11:26,650
entries the two rights and the two leads

1455
01:11:26,650 --> 01:11:29,030
I'm gonna draw with arrows that

1456
01:11:29,030 --> 01:11:31,340
constraints implied by those two rules

1457
01:11:31,340 --> 01:11:33,800
and then our order is gonna have to obey

1458
01:11:33,800 --> 01:11:36,440
these constraints so one constraint is

1459
01:11:36,440 --> 01:11:39,200
that this write finished before this

1460
01:11:39,200 --> 01:11:41,270
write started and therefore one of the

1461
01:11:41,270 --> 01:11:44,420
ordering constraints is that this write

1462
01:11:44,420 --> 01:11:47,480
must appear in the total order before

1463
01:11:47,480 --> 01:11:51,290
this write this read saw the value of

1464
01:11:51,290 --> 01:11:56,870
two so in the total order the most

1465
01:11:56,870 --> 01:11:59,090
recent right that this read must come

1466
01:11:59,090 --> 01:12:00,740
after this right and this write must be

1467
01:12:00,740 --> 01:12:03,610
the most recent right so that means that

1468
01:12:03,610 --> 01:12:06,320
in the total order we must see the right

1469
01:12:06,320 --> 01:12:08,930
of X - 2 and then after it the read of X

1470
01:12:08,930 --> 01:12:19,670
it yields - and this this read of X of 1

1471
01:12:19,670 --> 01:12:21,050
if we assume that the X didn't already

1472
01:12:21,050 --> 01:12:23,210
have the value 1 there there must be in

1473
01:12:23,210 --> 01:12:27,020
this relationship and that is the read

1474
01:12:27,020 --> 01:12:29,240
must come after the right and this read

1475
01:12:29,240 --> 01:12:32,750
also must become for this right and

1476
01:12:32,750 --> 01:12:35,480
maybe there's some other restrictions -

1477
01:12:35,480 --> 01:12:37,910
anyway we can take these we can take

1478
01:12:37,910 --> 01:12:39,260
this set of arrows and flatten it out

1479
01:12:39,260 --> 01:12:41,090
into an order and that actually works so

1480
01:12:41,090 --> 01:12:44,030
the order that's the total order that

1481
01:12:44,030 --> 01:12:45,590
demonstrates that this history is

1482
01:12:45,590 --> 01:12:50,020
linearizable is first the right of x - 1

1483
01:12:50,020 --> 01:12:56,510
then the read of x yielding 1 then the

1484
01:12:56,510 --> 01:13:00,650
right of x - 2 and the read of x that

1485
01:13:00,650 --> 01:13:03,190
yields 2

1486
01:13:03,920 --> 01:13:06,390
alright so the fact that there is this

1487
01:13:06,390 --> 01:13:07,920
order that does obey the ordering

1488
01:13:07,920 --> 01:13:09,449
constraints shows that this history is

1489
01:13:09,449 --> 01:13:13,980
linearize ability and doesn't you know

1490
01:13:13,980 --> 01:13:15,300
if we're worried about the system that

1491
01:13:15,300 --> 01:13:17,940
produced this history whether it's a but

1492
01:13:17,940 --> 01:13:20,610
that system is linearizable then this

1493
01:13:20,610 --> 01:13:22,110
particular example we saw it doesn't

1494
01:13:22,110 --> 01:13:24,660
contradict the presumption that the

1495
01:13:24,660 --> 01:13:29,040
system is linearizable any questions

1496
01:13:29,040 --> 01:13:45,360
about what I just did each read sees you

1497
01:13:45,360 --> 01:13:48,150
know read of X the value it sees must be

1498
01:13:48,150 --> 01:13:51,600
them value written by the most the most

1499
01:13:51,600 --> 01:13:56,330
recent proceeding right in the order so

1500
01:13:56,330 --> 01:13:58,920
you know in this case in this case we're

1501
01:13:58,920 --> 01:14:00,239
totally ok with this order because this

1502
01:14:00,239 --> 01:14:03,449
read the value it saw is indeed the

1503
01:14:03,449 --> 01:14:04,770
value written by the most recent write

1504
01:14:04,770 --> 01:14:08,250
in this order and this read the value it

1505
01:14:08,250 --> 01:14:12,630
sighs I mean in informally it's that

1506
01:14:12,630 --> 01:14:15,420
reads can't real should not be yielding

1507
01:14:15,420 --> 01:14:17,940
stale data if I write something in Rita

1508
01:14:17,940 --> 01:14:20,040
back gosh I should see the value I wrote

1509
01:14:20,040 --> 01:14:21,870
and that's like a formalization of the

1510
01:14:21,870 --> 01:14:24,230
notion that

1511
01:14:27,530 --> 01:14:34,130
oh yes oh yeah yeah all right let me let

1512
01:14:34,130 --> 01:14:40,430
me he's right up example that's not

1513
01:14:40,430 --> 01:14:44,810
indeed linearizable so example two let's

1514
01:14:44,810 --> 01:14:48,110
suppose our history is we had a right of

1515
01:14:48,110 --> 01:14:57,880
X value one right back with value two

1516
01:15:14,090 --> 01:15:16,640
and so this one we also want to write

1517
01:15:16,640 --> 01:15:20,120
out the arrows and so we know what the

1518
01:15:20,120 --> 01:15:21,920
constraints are on any total order we

1519
01:15:21,920 --> 01:15:26,120
might find the right of X to one because

1520
01:15:26,120 --> 01:15:28,580
of time because it finished in real time

1521
01:15:28,580 --> 01:15:31,130
before the right x to started and must

1522
01:15:31,130 --> 01:15:36,200
come before in any satisfying order we

1523
01:15:36,200 --> 01:15:38,510
produce the right of Ecsta two has to

1524
01:15:38,510 --> 01:15:41,060
come before the right before the read of

1525
01:15:41,060 --> 01:15:45,280
X that yields two so we have this arrow

1526
01:15:46,840 --> 01:15:49,400
the read of X had to finished before the

1527
01:15:49,400 --> 01:15:51,410
read of X to one started so we have this

1528
01:15:51,410 --> 01:16:00,260
arrow and the read of X to one because

1529
01:16:00,260 --> 01:16:03,830
it saw value one has to come after the

1530
01:16:03,830 --> 01:16:06,140
right of X - 1 and more crucially before

1531
01:16:06,140 --> 01:16:09,770
the right of X 2 - right so we can't

1532
01:16:09,770 --> 01:16:12,230
have this read of X yielding one if it's

1533
01:16:12,230 --> 01:16:14,240
immediately preceded by I'll write out X

1534
01:16:14,240 --> 01:16:18,250
- 2 so we also have this arrow like this

1535
01:16:18,250 --> 01:16:23,060
and because there's a cycle in these

1536
01:16:23,060 --> 01:16:27,110
constraints there's no order that can

1537
01:16:27,110 --> 01:16:29,150
obey all these constraints and therefore

1538
01:16:29,150 --> 01:16:35,180
this history is not linearizable and so

1539
01:16:35,180 --> 01:16:37,660
the system that produced it is

1540
01:16:37,660 --> 01:16:42,880
is not a linearizable system you know

1541
01:16:42,880 --> 01:16:44,320
would be linearizable the history was

1542
01:16:44,320 --> 01:16:47,740
missing any one of these three and I

1543
01:16:47,740 --> 01:17:05,770
would break the cycle yes maybe I'm not

1544
01:17:05,770 --> 01:17:08,620
sure because suppose or I don't know how

1545
01:17:08,620 --> 01:17:11,230
to incorporate very strange things like

1546
01:17:11,230 --> 01:17:16,870
supposing somebody red 27 you know it

1547
01:17:16,870 --> 01:17:18,910
doesn't really if there's no right of 27

1548
01:17:18,910 --> 01:17:22,360
a read of 27 doesn't at least the way

1549
01:17:22,360 --> 01:17:23,710
I've written out the rules doesn't sort

1550
01:17:23,710 --> 01:17:26,620
of well there may be some sort of anti

1551
01:17:26,620 --> 01:17:29,200
dependency that you would construct okay

1552
01:17:29,200 --> 01:17:33,130
um I will continue this discussion next

1553
01:17:33,130 --> 00:00:00,000
week

