它们都在同一条网络上传输
推测来看，这些
被主节点发往备份节点的事件
被称为在日志通道上的日志记录
容错出现的场景是
主节点挂掉了
备份节点觉察到它接受不到日志了
备份节点停止接受日志记录了
接收不到日志通道上的日志数据了
接收不到日志通道上的日志数据
我们知道备份节点
每秒可以接受许多事件，
因为其中的一些事件就是
由周期性的时钟中断触发产生的，
在主节点上，每个中断产生一个日志记录，
在主节点上，每个中断产生一个日志记录，
在主节点上，每个中断产生一个日志记录，
这些时钟中断可以以每秒100次的频率触发，
所以备份节点
理应接受到
日志通道上的许多通信消息
如果主节点还存活着的话
如果主节点挂掉的话，VMM监视器
会说：天哪，
我已经有一秒或者更长时间没有收到日志同道上的事件了
我已经有一秒或者更长时间没有收到日志同道上的事件了
那主节点应该挂掉了，
或者发生了其他事情，当发生这些事情时候，
备份节点接收不到主节点的日志记录时候，
论文中描述说，备份节点会启动
论文中描述说，备份节点会启动
它将停止接收来自主节点日志通道上的输入事件
它将停止接收来自主节点日志通道上的输入事件
它将停止接收来自主节点日志通道上的输入事件
相反VMM
会让备份节点开始自由执行
而不需要通过主节点的输入事件来驱动执行
而不需要通过主节点的输入事件来驱动执行
同时VMM会变更网络层配置信息
让未来的客户端请求路由到备份节点上
而不是到原来的主节点上
VMM此时停止之前抛弃备份节点返回数据的策略
此时原来旧的主节点
开始抛弃输出数据
所以这台机器开始
接受输入事件，
并且输出输出事件
这样我们的备份节点完成接管流程
类似的这个接管流程不是非常有趣
但是需要能正常的work
如果备份节点挂掉了，主节点
需要用同样的一套机制来放弃备份节点
停止向备份节点发送日志记录
此时主节点更像是一个单节点的
没有复制功能的服务，
所以它们中的一个会变活
当另一个挂掉的时候，或者停止发送网络流量
当另一个挂掉的时候，或者停止发送网络流量
神奇，这个得看具体情况
看具体的网络拓扑结构是怎样的
我认为论文中的一个可能是
在Ethernet层基础上
每一个物理机或者NIC卡
有一个48bit的唯一ID
也有可能是另一种情况
并不是每一个物理机
有一个唯一Id，而是每一个虚拟机有一个唯一Id
当备份节点接管的时候
它会申明
主节点的Ethernet Id变成它自己的Id
然后对外声明它是那个唯一Id的所有者
这样网络上的其他节点
就会向我们发送数据包，这是我这边的理解
这套机制的设计者
相信他们确认了所有的事件源
针对每一个这样的事件源，主节点
都会执行，如你所知，不管是
一个随机数生成指令，或者
在某个时间点触发一个中断事件，
但是备份节点并不执行这些操作，VMM的备份节点
会检测到这些指令
会截获这些指令
并且不执行它，备份节点
会等待日志通道上的一个对应的日志事件
告诉它具体的指令结果是啥
你知道的，那就是在主节点上产生的那个随机数
你知道的，那就是在主节点上产生的那个随机数
在哪个节点？
是的是的
论文暗示了他们让Intel
在微处理器上加入了一些特性
来支持这个功能，但是他们没有说
到底是什么
关于这个主题，到现在为止
你们知道的是
只要备份节点能够收到
从client发送过来的数据包
它就会和主节点保持一致的执行它
但实际上我们忽略了一些巨大和重要的细节
其中的一个问题就是
许多人之前提到的
有一些操作是非确定性的
事情并不是这样的
发生在机器里的每一个操作并不一定是内存内容
的确定性函数映射关系
的确定性函数映射关系
对一些常见的直接代码执行操作是确定性的
对一些常见的直接代码执行操作是确定性的
但是并不总是这样的，我们担心的是
某些操作并不是当前状态的严格函数关系
某些操作并不是当前状态的严格函数关系
即结果可能不一样，如果我们没有细心的考虑
主节点和备份节点之间的关系
所以这是一些非确定性的事件
它们的存在使设计者们不得不
坐下来好好思考弄清楚
它们要如何工作才行
这里是他们要讨论的内容
其中的一个是外部源的输入事件
这些事件随便什么时候都可以到来
这些事件随便什么时候都可以到来
它们是不可预测的，没有道理可以预先知道这些请求什么时候到来
没有道理可以预先知道这些请求什么时候到来
或者它的内容是服务状态的确定性映射关系，因为它并不是
或者它的内容是服务状态的确定性映射关系，因为它并不是
所以呢
所以这个系统真正面对的是一个服务之间通过网络进行交互的场景
所以这个系统真正面对的是一个服务之间通过网络进行交互的场景
所以这个系统仅有的的输入和输出方式
所以这个系统仅有的的输入和输出方式
是通过网络包的输入和输出形式来支撑的。
是通过网络包的输入和输出形式来支撑的。
所以我们没有把到达操作记录下来，它真正的意思是一个数据包到达了
它真正的意思是一个数据包到达了
它真正的意思是一个数据包到达了
同时一个数据包是由
数据包中的数据
加上用来通知数据到达的中断事件组成的
加上用来通知数据到达的中断事件组成的
这一点是非常重要的
所以当一个数据包到达的时候
NIC卡通过DMA机制将包内容拷贝到内存
然后触发中断操作
操作系统收到中断事件
同时这个中断会在指令流的某个时间点执行
同时这个中断会在指令流的某个时间点执行
所有这些操作在主节点和备份节点必需看起来是一样的
所有这些操作在主节点和备份节点必需看起来是一样的
否则我们将会看到有些操作将会引起分叉
所以你知道真正的问题是
当中断真正的在某一条指令执行触发的时候，
当中断真正的在某一条指令执行触发的时候，
这个需要在主节点和备份节点是一致的
否则它们的执行可能出现不一致，他们的状态也将出现分叉
否则它们的执行可能出现不一致，他们的状态也将出现分叉
所以我们需要关注数据包的内容，中断的时序
所以我们需要关注数据包的内容，中断的时序
中断的时序以及
其他人提到的
有一些指令
在不同的机器上有不用的执行结果
或者依赖其他情况
比如一个随机数生成器
或者获取时间的指令
在不同时间执行会获取到不同的结果
在不同时间执行会获取到不同的结果
或者是唯一Id生成指令
另一个非确定性的主要来源
但是在论文中被显式剔除掉的
多核并行的场景，论文假定了一个单核处理，
并不存在多核情况的世界
这样做的原因是
如果允许存在多核处理的话，
服务将会运行在多个核上
这样的话服务的指令
如我们所知晓的，不同的核将交叉执行指令
不同的核将以某种方式交叉执行指令
但是这个次序是不可预知的，所以如果我们
在备份节点执行相同的指令
这些在多核上执行的并行指令
电子器件将在两个核上以不同的组合方式交叉执行这些指令
电子器件将在两个核上以不同的组合方式交叉执行这些指令
电子器件将在两个核上以不同的组合方式交叉执行这些指令
那样会导致出现不同的计算结果，
因为你知道
设想这些代码执行在两个核上
它们都在获取某些数据的锁
在主节点上
核芯1有可能比核芯2先获得了锁
但是在备份节点上，可能仅仅是由于一个很小
的时序差异，核芯2可能先获取到锁
这样的话执行结果
是完全不一样的，
执行结果可能是完全不一样的，如果是由
不同的线程获取了锁
所以多核场景是很糟糕的一种
导致非确定性的源头
在这篇论文中仅仅是禁止出现这种场景，
就我所知道的而言，论文中的这些技术
在实际中不是很实用。
服务不用实用多核并行














