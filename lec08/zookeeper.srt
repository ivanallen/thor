1
00:00:01,600 --> 00:00:05,000
alright last time I started talking

2
00:00:05,000 --> 00:00:06,770
about linearize ability and I want to

3
00:00:06,770 --> 00:00:09,290
finish up this time the reason why we're

4
00:00:09,290 --> 00:00:11,660
talking about it again is that it's our

5
00:00:11,660 --> 00:00:14,000
kind of standard definition for what

6
00:00:14,000 --> 00:00:19,039
strong consistency means in storage

7
00:00:19,039 --> 00:00:23,079
style systems so for example lab 3 is a

8
00:00:23,079 --> 00:00:28,369
needs to obey your lab 3 needs to be

9
00:00:28,369 --> 00:00:31,369
linearizable and sometimes this will

10
00:00:31,369 --> 00:00:32,930
come up because we're talking about a

11
00:00:32,930 --> 00:00:34,310
strongly consistent system and we're

12
00:00:34,310 --> 00:00:35,360
wondering whether a particular behavior

13
00:00:35,360 --> 00:00:39,170
is acceptable and other times linearize

14
00:00:39,170 --> 00:00:40,760
ability will become come up because

15
00:00:40,760 --> 00:00:42,140
we'll be talking about a system that

16
00:00:42,140 --> 00:00:44,000
isn't linearizable and we'll be

17
00:00:44,000 --> 00:00:47,150
wondering you know in what ways might it

18
00:00:47,150 --> 00:00:49,520
fall short or deviate from linearize

19
00:00:49,520 --> 00:00:51,350
ability so one thing you need to be able

20
00:00:51,350 --> 00:00:55,160
to do is look at a particular sequence

21
00:00:55,160 --> 00:00:59,150
of operations a particular execution of

22
00:00:59,150 --> 00:01:00,950
some system that executes reads and

23
00:01:00,950 --> 00:01:03,260
writes like your lab 3 and be able to

24
00:01:03,260 --> 00:01:04,699
answer the question oh was that was that

25
00:01:04,699 --> 00:01:06,609
sequence of operations I just saw

26
00:01:06,609 --> 00:01:10,490
linearizable or not I'm so we're going

27
00:01:10,490 --> 00:01:11,929
to continue practicing that a little bit

28
00:01:11,929 --> 00:01:16,549
now plus I'll try to actually establish

29
00:01:16,549 --> 00:01:17,719
some interesting facts that will be

30
00:01:17,719 --> 00:01:19,789
helpful for us about what it means about

31
00:01:19,789 --> 00:01:21,829
the consequences for the systems we

32
00:01:21,829 --> 00:01:26,630
build and look at linearize ability is

33
00:01:26,630 --> 00:01:28,729
to find on particular operation history

34
00:01:28,729 --> 00:01:31,429
so always the thing we're talking about

35
00:01:31,429 --> 00:01:34,880
is oh we observed you know a sequence of

36
00:01:34,880 --> 00:01:36,859
requests by clients and then they got

37
00:01:36,859 --> 00:01:39,139
some responses at different times and

38
00:01:39,139 --> 00:01:41,240
they asked for different different you

39
00:01:41,240 --> 00:01:44,179
know to read different data and got

40
00:01:44,179 --> 00:01:46,549
various answers back you know is that

41
00:01:46,549 --> 00:01:50,380
history that we saw linearizable ok so

42
00:01:50,380 --> 00:01:53,299
here's an example of a history that

43
00:01:53,299 --> 00:01:55,969
might or might not be linearized able so

44
00:01:55,969 --> 00:01:57,770
let's suppose at some point in time some

45
00:01:57,770 --> 00:01:59,840
client groups of times gonna move to the

46
00:01:59,840 --> 00:02:02,060
right this vertical bar marks the time

47
00:02:02,060 --> 00:02:05,929
at which a client sent a request I'm

48
00:02:05,929 --> 00:02:08,780
gonna use this notation to mean that the

49
00:02:08,780 --> 00:02:12,430
request is a write and asks to set

50
00:02:12,430 --> 00:02:17,980
variable or key or whatever x to value 0

51
00:02:17,980 --> 00:02:20,659
so sort of a key and a value this would

52
00:02:20,659 --> 00:02:23,689
correspond to a put of key X and by zero

53
00:02:23,689 --> 00:02:28,370
in lab 3 and then this is sort of we're

54
00:02:28,370 --> 00:02:29,780
watching what the client send the client

55
00:02:29,780 --> 00:02:32,629
sent this request to our service and at

56
00:02:32,629 --> 00:02:34,670
some point the service responded and

57
00:02:34,670 --> 00:02:37,159
said yes you're right is completed so

58
00:02:37,159 --> 00:02:38,510
we're assuming the services of a nature

59
00:02:38,510 --> 00:02:40,459
that actually tells you when the write

60
00:02:40,459 --> 00:02:43,879
completes otherwise the definition isn't

61
00:02:43,879 --> 00:02:46,069
very useful ok so we have this request

62
00:02:46,069 --> 00:02:49,939
by somebody to write and then I'm

63
00:02:49,939 --> 00:02:51,560
imagining in this example there's

64
00:02:51,560 --> 00:02:54,769
another request that because I'm putting

65
00:02:54,769 --> 00:02:56,269
this mark here this means the second

66
00:02:56,269 --> 00:02:59,689
request started after the first request

67
00:02:59,689 --> 00:03:01,969
finished and and you know reason why

68
00:03:01,969 --> 00:03:04,760
that's important is because of this rule

69
00:03:04,760 --> 00:03:07,370
that linearizable history must match

70
00:03:07,370 --> 00:03:10,129
real time and what that really means is

71
00:03:10,129 --> 00:03:12,349
that requests that are known in real

72
00:03:12,349 --> 00:03:15,379
time to have started after some other

73
00:03:15,379 --> 00:03:18,799
request finished the second request has

74
00:03:18,799 --> 00:03:20,569
to occur after the first request in

75
00:03:20,569 --> 00:03:22,879
whatever order we work out that's the

76
00:03:22,879 --> 00:03:24,469
proof that the history was a linearized

77
00:03:24,469 --> 00:03:27,079
linearize available ok so in this

78
00:03:27,079 --> 00:03:29,000
example I'm imagining there's another

79
00:03:29,000 --> 00:03:31,909
request that asks to write X to have

80
00:03:31,909 --> 00:03:36,530
value 1 and then a concurrent request

81
00:03:36,530 --> 00:03:39,650
may be started a little bit later as to

82
00:03:39,650 --> 00:03:44,329
set X to 2 I said now we have two maybe

83
00:03:44,329 --> 00:03:46,069
two different clients issued requests at

84
00:03:46,069 --> 00:03:47,750
about the same time to set X to two

85
00:03:47,750 --> 00:03:49,549
different values so of course we're

86
00:03:49,549 --> 00:03:51,890
wondering which one is going to be the

87
00:03:51,890 --> 00:03:54,890
real value and then we also have some

88
00:03:54,890 --> 00:04:01,239
reads if all you have is writes well

89
00:04:01,450 --> 00:04:04,010
all you have is writes so it's it's hard

90
00:04:04,010 --> 00:04:05,659
to say too much about linearizable

91
00:04:05,659 --> 00:04:07,370
linearize ability because you don't know

92
00:04:07,370 --> 00:04:10,849
you don't have any proof that the system

93
00:04:10,849 --> 00:04:12,620
actually did anything or revealed any

94
00:04:12,620 --> 00:04:17,839
values so we really need reads so let's

95
00:04:17,839 --> 00:04:21,048
imagine we have some read unless you'll

96
00:04:21,048 --> 00:04:23,290
be seeing our in the history

97
00:04:23,290 --> 00:04:27,070
that a client said to read at this time

98
00:04:27,070 --> 00:04:30,010
and the second time it got an answer for

99
00:04:30,010 --> 00:04:34,300
read key x got value 2

100
00:04:34,300 --> 00:04:37,450
presumably actually saw this value and

101
00:04:37,450 --> 00:04:39,100
then there was another request by maybe

102
00:04:39,100 --> 00:04:40,390
the same client or a different client

103
00:04:40,390 --> 00:04:43,060
but known to have started in time after

104
00:04:43,060 --> 00:04:46,270
this request finished and this read of X

105
00:04:46,270 --> 00:04:50,980
got value while and so the question in

106
00:04:50,980 --> 00:04:52,900
front of us is is this history

107
00:04:52,900 --> 00:04:55,300
linearizable and there's sort of two

108
00:04:55,300 --> 00:04:58,450
strategies we can take we can either

109
00:04:58,450 --> 00:05:00,820
cook up a sequence because if we can

110
00:05:00,820 --> 00:05:03,700
come up with a total order of these five

111
00:05:03,700 --> 00:05:06,790
operations that obeys real time and in

112
00:05:06,790 --> 00:05:09,400
which each read sees the value written

113
00:05:09,400 --> 00:05:12,400
by the priest most recently proceeding

114
00:05:12,400 --> 00:05:13,690
right in the order if we can come up

115
00:05:13,690 --> 00:05:15,490
with that order then that's a proof the

116
00:05:15,490 --> 00:05:17,770
history is linearizable another strategy

117
00:05:17,770 --> 00:05:23,140
is to observe that these rules each one

118
00:05:23,140 --> 00:05:26,730
may imply certain this comes before that

119
00:05:26,730 --> 00:05:29,800
edges in a graph and if we can find a

120
00:05:29,800 --> 00:05:32,140
cycle in this operation must come before

121
00:05:32,140 --> 00:05:33,970
that operation we can find a cycle on

122
00:05:33,970 --> 00:05:35,980
that graph and that's proof that the

123
00:05:35,980 --> 00:05:39,040
history isn't linearizable and for small

124
00:05:39,040 --> 00:05:40,240
histories we may actually be able to

125
00:05:40,240 --> 00:05:42,280
enumerate every single order and use

126
00:05:42,280 --> 00:05:45,550
that show this history isn't

127
00:05:45,550 --> 00:05:51,280
linearizable anyway any any any thoughts

128
00:05:51,280 --> 00:05:53,980
about whether this might be or might not

129
00:05:53,980 --> 00:05:56,730
be linearizable

130
00:06:00,410 --> 00:06:03,130
yes

131
00:06:08,330 --> 00:06:11,330
yes okay so the observation is that um

132
00:06:11,330 --> 00:06:15,560
it's a little bit troubling that we saw

133
00:06:15,560 --> 00:06:17,330
read with IU - and then the read with

134
00:06:17,330 --> 00:06:21,099
value want and maybe that contradicts

135
00:06:21,099 --> 00:06:23,210
you know there were two rights one with

136
00:06:23,210 --> 00:06:25,490
value one on one value - so that so we

137
00:06:25,490 --> 00:06:26,840
certainly if we had to read with value

138
00:06:26,840 --> 00:06:28,970
three that would obviously be something

139
00:06:28,970 --> 00:06:31,159
I got terribly wrong you know but we got

140
00:06:31,159 --> 00:06:32,720
there were a right of one in two and a

141
00:06:32,720 --> 00:06:34,849
read of one and two so the question is

142
00:06:34,849 --> 00:06:36,470
whether this order of reads could

143
00:06:36,470 --> 00:06:39,349
possibly be reconciled with the way

144
00:06:39,349 --> 00:06:43,030
these two rights show up in the history

145
00:06:59,289 --> 00:07:04,580
okay so what I'm what I'm the game we're

146
00:07:04,580 --> 00:07:07,520
playing is that we have a like maybe two

147
00:07:07,520 --> 00:07:08,960
clients or three clients and they're

148
00:07:08,960 --> 00:07:10,789
talking some service you know maybe a

149
00:07:10,789 --> 00:07:12,710
raft last year something and what we are

150
00:07:12,710 --> 00:07:15,529
seeing is requests and responses right

151
00:07:15,529 --> 00:07:18,259
so what this means is that we saw

152
00:07:18,259 --> 00:07:21,680
requests from a client to write X to the

153
00:07:21,680 --> 00:07:23,539
you know put requests for X and one and

154
00:07:23,539 --> 00:07:25,219
we saw the response here so what we know

155
00:07:25,219 --> 00:07:27,289
is that somewhere during this interval

156
00:07:27,289 --> 00:07:29,319
of time presumably the service actually

157
00:07:29,319 --> 00:07:32,210
internally change the value of x - 1 and

158
00:07:32,210 --> 00:07:34,610
what this means is that somewhere in

159
00:07:34,610 --> 00:07:38,919
this interval of time the service

160
00:07:38,919 --> 00:07:42,590
presumably changed its internal idea of

161
00:07:42,590 --> 00:07:44,150
the value of x - 2 somewhere in this

162
00:07:44,150 --> 00:07:47,029
time but you know it's just somewhere in

163
00:07:47,029 --> 00:07:48,889
this time it doesn't mean it happened

164
00:07:48,889 --> 00:07:52,250
here or here does that answer your

165
00:07:52,250 --> 00:07:53,590
question

166
00:07:53,590 --> 00:07:56,590
yes

167
00:08:07,889 --> 00:08:10,620
yes okay so the observation is that is

168
00:08:10,620 --> 00:08:13,500
linearizable and it's been accompanied

169
00:08:13,500 --> 00:08:15,689
by an actual proof of the linearize

170
00:08:15,689 --> 00:08:17,490
ability namely a demonstration of the

171
00:08:17,490 --> 00:08:19,979
order that shows that it is linearizable

172
00:08:19,979 --> 00:08:25,259
and the order is yes it's linearizable

173
00:08:25,259 --> 00:08:32,070
and the order is first right of X with

174
00:08:32,070 --> 00:08:36,929
value 0 and the server got both of these

175
00:08:36,929 --> 00:08:38,490
rights at roughly the same time it's

176
00:08:38,490 --> 00:08:40,529
still had to choose the order itself all

177
00:08:40,529 --> 00:08:43,140
right so let's just say it could have

178
00:08:43,140 --> 00:08:45,890
executed the right of x2 value 2 first

179
00:08:45,890 --> 00:08:54,089
and then the read of X then executed the

180
00:08:54,089 --> 00:08:58,589
read of X which would the first read of

181
00:08:58,589 --> 00:09:01,230
X which at that point would yield 2 and

182
00:09:01,230 --> 00:09:03,450
then we're gonna say the next operation

183
00:09:03,450 --> 00:09:05,040
had executed it was the right of X to 1

184
00:09:05,040 --> 00:09:08,430
and then the last operation in the

185
00:09:08,430 --> 00:09:16,260
history is the read of X to 1 and so

186
00:09:16,260 --> 00:09:17,670
this is proof that the history is

187
00:09:17,670 --> 00:09:19,430
linearizable because here's an order

188
00:09:19,430 --> 00:09:22,350
it's a total order of the operations and

189
00:09:22,350 --> 00:09:24,810
this is the order it matches real time

190
00:09:24,810 --> 00:09:29,310
so what that means is well just go

191
00:09:29,310 --> 00:09:31,170
through it the the right of X to 0 comes

192
00:09:31,170 --> 00:09:32,339
first and that's that's totally

193
00:09:32,339 --> 00:09:33,660
intuitive since it's actually finished

194
00:09:33,660 --> 00:09:37,560
before any other operations started the

195
00:09:37,560 --> 00:09:40,320
right of X to 1 comes sorry the rate of

196
00:09:40,320 --> 00:09:42,060
X to 2 comes second so we're gonna say

197
00:09:42,060 --> 00:09:46,920
maybe that I'm gonna mark here that sort

198
00:09:46,920 --> 00:09:48,839
of real time at which we imagine these

199
00:09:48,839 --> 00:09:50,699
operations happen to demonstrate that

200
00:09:50,699 --> 00:09:52,800
the order here does match real time so

201
00:09:52,800 --> 00:09:54,300
it'll say I'll just write a big X here

202
00:09:54,300 --> 00:09:56,220
to mark the time when we imagine this

203
00:09:56,220 --> 00:09:59,160
operation happened all right so that's

204
00:09:59,160 --> 00:10:01,949
the second operation then we're

205
00:10:01,949 --> 00:10:03,720
imagining that the next operation is the

206
00:10:03,720 --> 00:10:07,380
read of X of 2 we you know there's no

207
00:10:07,380 --> 00:10:08,820
real time problem because the read of X

208
00:10:08,820 --> 00:10:11,070
of 2 actually was this u concurrently

209
00:10:11,070 --> 00:10:13,079
with the right of X of 2 you know it's

210
00:10:13,079 --> 00:10:14,640
not like the right of X the read of X of

211
00:10:14,640 --> 00:10:16,110
2 finished and only then did the right

212
00:10:16,110 --> 00:10:18,660
of X right of X with to start there

213
00:10:18,660 --> 00:10:20,069
really are concurrent we'll just imagine

214
00:10:20,069 --> 00:10:21,240
that that

215
00:10:21,240 --> 00:10:23,519
sort of point in time at which this

216
00:10:23,519 --> 00:10:25,230
operation happened is right there so

217
00:10:25,230 --> 00:10:27,449
this is the you know we don't care when

218
00:10:27,449 --> 00:10:28,589
this one happened let's just say there's

219
00:10:28,589 --> 00:10:33,269
the first operation second third now we

220
00:10:33,269 --> 00:10:36,660
have a right of X of one let's just say

221
00:10:36,660 --> 00:10:39,089
it happens here in real time just has to

222
00:10:39,089 --> 00:10:42,779
happen after the operations that occur

223
00:10:42,779 --> 00:10:43,949
before it in the order so that will say

224
00:10:43,949 --> 00:10:45,600
there's the fourth operation and now we

225
00:10:45,600 --> 00:10:47,009
have the read of x1 and it can pretty

226
00:10:47,009 --> 00:10:48,929
much happen at any time but let's say it

227
00:10:48,929 --> 00:10:52,439
happens here okay so this is the

228
00:10:52,439 --> 00:10:52,889
Diamonds

229
00:10:52,889 --> 00:10:54,360
so we have the order this is the

230
00:10:54,360 --> 00:10:56,369
demonstration that the order is

231
00:10:56,369 --> 00:10:58,259
consistent with real time that is we can

232
00:10:58,259 --> 00:11:00,089
pick a time for each of the operations

233
00:11:00,089 --> 00:11:02,850
that's within its start and end time

234
00:11:02,850 --> 00:11:06,600
that would cause this total order to

235
00:11:06,600 --> 00:11:08,910
match our real time order and so the

236
00:11:08,910 --> 00:11:12,269
final question is did each read see the

237
00:11:12,269 --> 00:11:14,249
value written by the most closely

238
00:11:14,249 --> 00:11:16,939
preceding right of the same variable so

239
00:11:16,939 --> 00:11:20,189
there's two V's this read preceded by a

240
00:11:20,189 --> 00:11:21,899
right with that correct value so that's

241
00:11:21,899 --> 00:11:23,550
good and this read is preceded by a

242
00:11:23,550 --> 00:11:26,549
right most closely preceded by a right

243
00:11:26,549 --> 00:11:32,670
of the same value also okay so this this

244
00:11:32,670 --> 00:11:34,649
is a demonstration that this history was

245
00:11:34,649 --> 00:11:39,089
linearizable and you know the you know

246
00:11:39,089 --> 00:11:40,769
depends on what you thought when you

247
00:11:40,769 --> 00:11:42,990
first saw the history but it's not

248
00:11:42,990 --> 00:11:44,819
always immediately clear that set up

249
00:11:44,819 --> 00:11:47,490
this complicated is you know it's easy

250
00:11:47,490 --> 00:11:50,429
to be tricked when looking at these

251
00:11:50,429 --> 00:11:51,540
histories which do you think oh the

252
00:11:51,540 --> 00:11:53,699
right of x1 started first so we just

253
00:11:53,699 --> 00:11:56,069
sort of assumed that the first value

254
00:11:56,069 --> 00:11:57,689
written must be one but that's actually

255
00:11:57,689 --> 00:12:03,540
not required here any questions about

256
00:12:03,540 --> 00:12:05,779
this

257
00:12:15,089 --> 00:12:18,239
if the you mean if these two were moved

258
00:12:18,239 --> 00:12:23,219
like this the okay so if if if this if

259
00:12:23,219 --> 00:12:26,099
the right with value to was only issued

260
00:12:26,099 --> 00:12:30,329
by the client after the read of accent

261
00:12:30,329 --> 00:12:33,779
value to returned that wouldn't be

262
00:12:33,779 --> 00:12:37,319
linearizable because in whatever order

263
00:12:37,319 --> 00:12:39,089
you know any order we come up with has

264
00:12:39,089 --> 00:12:41,129
to obey the real-time ordering so any

265
00:12:41,129 --> 00:12:42,629
order we come up with would have had to

266
00:12:42,629 --> 00:12:46,289
have the read of X with to precede the

267
00:12:46,289 --> 00:12:48,899
right of X with 2 and since there's no

268
00:12:48,899 --> 00:12:52,799
other right of X of 2 insight here that

269
00:12:52,799 --> 00:12:55,079
means that a read at this point could

270
00:12:55,079 --> 00:12:57,029
only see 0 or 1 because those are the

271
00:12:57,029 --> 00:12:59,549
only other 2 rights that could possibly

272
00:12:59,549 --> 00:13:03,329
come before this read so moving you know

273
00:13:03,329 --> 00:13:06,089
shifting these that much makes the would

274
00:13:06,089 --> 00:13:10,459
make the example not linearizable

275
00:13:19,090 --> 00:13:22,090
yes

276
00:13:24,670 --> 00:13:27,260
I'm saying that the first vertical line

277
00:13:27,260 --> 00:13:29,690
is the moment the client sends the

278
00:13:29,690 --> 00:13:32,360
request and the second vertical line is

279
00:13:32,360 --> 00:13:34,130
the moment the client receives the

280
00:13:34,130 --> 00:13:39,560
request yes yeah yeah so this is a very

281
00:13:39,560 --> 00:13:42,890
client centric kind of definition it

282
00:13:42,890 --> 00:13:44,540
says you know clients should see the

283
00:13:44,540 --> 00:13:46,580
following behavior and what happens

284
00:13:46,580 --> 00:13:48,380
after us send a request in maybe there's

285
00:13:48,380 --> 00:13:49,970
a lot of replicas maybe a complicated

286
00:13:49,970 --> 00:13:51,740
network who knows what it's almost none

287
00:13:51,740 --> 00:13:53,570
of our business we're only the

288
00:13:53,570 --> 00:13:56,180
definition is only about what clients

289
00:13:56,180 --> 00:13:59,240
see there's some gray areas which we'll

290
00:13:59,240 --> 00:14:01,040
come to in a moment like if the client

291
00:14:01,040 --> 00:14:03,920
should need to retransmit a request then

292
00:14:03,920 --> 00:14:05,630
we also have to you know that's

293
00:14:05,630 --> 00:14:12,680
something we have to think about okay so

294
00:14:12,680 --> 00:14:16,400
this one is linearizable here's another

295
00:14:16,400 --> 00:14:19,700
example I'm actually going to start out

296
00:14:19,700 --> 00:14:22,400
with it being almost identical I'm gonna

297
00:14:22,400 --> 00:14:23,450
start out with you being identical for

298
00:14:23,450 --> 00:14:25,100
the first example so again we have a

299
00:14:25,100 --> 00:14:28,460
right of X with 0 we have these two

300
00:14:28,460 --> 00:14:38,150
concurrent rights and we have the same

301
00:14:38,150 --> 00:14:52,820
two reads those are so far identical to

302
00:14:52,820 --> 00:14:54,530
the previous example so therefore we

303
00:14:54,530 --> 00:14:56,090
know this must be this alone must be

304
00:14:56,090 --> 00:14:58,250
minimal but I'm going to add let's let's

305
00:14:58,250 --> 00:15:02,420
imagine that client 1 issued these two

306
00:15:02,420 --> 00:15:04,310
requests the definition doesn't really

307
00:15:04,310 --> 00:15:06,230
care about clients but her own sanity

308
00:15:06,230 --> 00:15:08,570
will assume client 1 red X and saw two

309
00:15:08,570 --> 00:15:11,450
and then later red X and saw one but

310
00:15:11,450 --> 00:15:13,880
that's okay so far I say there's another

311
00:15:13,880 --> 00:15:17,630
client and the other client does a read

312
00:15:17,630 --> 00:15:23,090
of X and it sees a 1 and then the other

313
00:15:23,090 --> 00:15:25,700
client is a second read of X and it sees

314
00:15:25,700 --> 00:15:31,280
- so this is linearizable and we either

315
00:15:31,280 --> 00:15:33,260
have to come up with an order

316
00:15:33,260 --> 00:15:39,890
or this comes before that graph that has

317
00:15:39,890 --> 00:15:42,460
a cycle in it

318
00:15:50,210 --> 00:15:54,410
so you know that thing this is getting

319
00:15:54,410 --> 00:15:57,110
at the puzzle is if one client saw

320
00:15:57,110 --> 00:15:59,990
there's only two rights here so they you

321
00:15:59,990 --> 00:16:01,700
know in any order or one of the rights

322
00:16:01,700 --> 00:16:03,320
comes first or the other rate comes

323
00:16:03,320 --> 00:16:08,089
first and intuitively client one

324
00:16:08,089 --> 00:16:10,370
observed that the right with value to

325
00:16:10,370 --> 00:16:14,870
came first and then the right of value

326
00:16:14,870 --> 00:16:19,010
one right these two reads mean that has

327
00:16:19,010 --> 00:16:21,560
to be the case that in any legal order

328
00:16:21,560 --> 00:16:23,000
of the right of two has to come before

329
00:16:23,000 --> 00:16:25,190
the right of one in order for the climb

330
00:16:25,190 --> 00:16:27,580
when to have seen this and it's the same

331
00:16:27,580 --> 00:16:31,100
order we saw over here but symmetrically

332
00:16:31,100 --> 00:16:33,830
client one's experience clearly shows

333
00:16:33,830 --> 00:16:39,070
the opposite right sorry huh fine to

334
00:16:39,070 --> 00:16:41,209
client who's experience was the opposite

335
00:16:41,209 --> 00:16:44,209
clients to saw the right of one first

336
00:16:44,209 --> 00:16:47,800
and then the right with value too and

337
00:16:47,800 --> 00:16:52,040
one of the rules here is that there's

338
00:16:52,040 --> 00:16:56,089
just one total order of operations not

339
00:16:56,089 --> 00:16:58,130
allowed to have different clients see

340
00:16:58,130 --> 00:17:00,910
different histories or different

341
00:17:00,910 --> 00:17:03,680
different progressions evolutions of the

342
00:17:03,680 --> 00:17:05,420
values that are stored in the system

343
00:17:05,420 --> 00:17:07,069
there can only be one total of order

344
00:17:07,069 --> 00:17:09,970
that all clients have to experience

345
00:17:09,970 --> 00:17:11,809
operations that are consistent with the

346
00:17:11,809 --> 00:17:16,280
one order and if one this one client

347
00:17:16,280 --> 00:17:18,319
clearly implies that the order is right

348
00:17:18,319 --> 00:17:21,050
- and then right one and so we should

349
00:17:21,050 --> 00:17:23,720
not be able to have any other client who

350
00:17:23,720 --> 00:17:25,790
observes proof that the order was

351
00:17:25,790 --> 00:17:29,559
anything else which is what we have here

352
00:17:29,559 --> 00:17:34,390
and so that's a bit of a intuitive

353
00:17:34,390 --> 00:17:37,370
explanation for what's going wrong here

354
00:17:37,370 --> 00:17:38,900
and and by the way the reason why this

355
00:17:38,900 --> 00:17:41,300
could come up in the systems that we

356
00:17:41,300 --> 00:17:43,429
build and look at is that we're building

357
00:17:43,429 --> 00:17:46,070
replicated systems either you know raft

358
00:17:46,070 --> 00:17:48,860
replicas or maybe systems with caching

359
00:17:48,860 --> 00:17:50,300
in them but we're building systems that

360
00:17:50,300 --> 00:17:52,220
have many copies of the data and so

361
00:17:52,220 --> 00:17:54,950
there may be many servers with copies of

362
00:17:54,950 --> 00:17:57,679
X in them possibly with different values

363
00:17:57,679 --> 00:17:59,210
at different times right if they haven't

364
00:17:59,210 --> 00:18:01,190
gotten the commits yet or something some

365
00:18:01,190 --> 00:18:03,470
replicas may have one value some may of

366
00:18:03,470 --> 00:18:03,860
the other

367
00:18:03,860 --> 00:18:07,070
but in spite of that if our system is

368
00:18:07,070 --> 00:18:09,440
linearizable or strongly consistent it

369
00:18:09,440 --> 00:18:13,130
must behave as if there was only one

370
00:18:13,130 --> 00:18:16,460
copy of the data and one linear sequence

371
00:18:16,460 --> 00:18:18,740
of operations applied to the data that's

372
00:18:18,740 --> 00:18:20,420
why this is an interesting example

373
00:18:20,420 --> 00:18:22,660
because this could come up in a sort of

374
00:18:22,660 --> 00:18:25,010
buggy system that had two copies of the

375
00:18:25,010 --> 00:18:27,260
data and one copy executed these rights

376
00:18:27,260 --> 00:18:28,760
in one order and the other replicas

377
00:18:28,760 --> 00:18:30,320
executed the rights in the other order

378
00:18:30,320 --> 00:18:32,570
and then we could see this and linearize

379
00:18:32,570 --> 00:18:34,880
ability says no we can't see that we're

380
00:18:34,880 --> 00:18:35,929
not allowed to see that in the correct

381
00:18:35,929 --> 00:18:39,679
system so the the cycle in the graph in

382
00:18:39,679 --> 00:18:44,090
the this comes before that graph that

383
00:18:44,090 --> 00:18:45,799
would be a sort of slightly more proof e

384
00:18:45,799 --> 00:18:47,660
proof that this is not linearizable is

385
00:18:47,660 --> 00:18:51,260
that the right of two has to come before

386
00:18:51,260 --> 00:18:55,340
client ones read of two so there's one

387
00:18:55,340 --> 00:18:59,210
arrow like this so this right has to

388
00:18:59,210 --> 00:19:05,260
come before that read client ones read

389
00:19:05,260 --> 00:19:09,380
has to come before the right of X with

390
00:19:09,380 --> 00:19:13,700
value one otherwise this read wouldn't

391
00:19:13,700 --> 00:19:15,830
be able to see one right if this you can

392
00:19:15,830 --> 00:19:17,030
imagine this right might happen very

393
00:19:17,030 --> 00:19:20,000
early in the order but in that case this

394
00:19:20,000 --> 00:19:21,740
read of X wouldn't see one it would see

395
00:19:21,740 --> 00:19:25,090
two since we know this guy saw two so

396
00:19:25,090 --> 00:19:28,900
the read of X with two must come before

397
00:19:28,900 --> 00:19:32,809
the right of X with one the right of X

398
00:19:32,809 --> 00:19:34,580
of one must come before any read of X

399
00:19:34,580 --> 00:19:37,190
with value 1 because including client

400
00:19:37,190 --> 00:19:42,679
who's read of X with value 1 but in

401
00:19:42,679 --> 00:19:44,600
order to get value 1 here and for this

402
00:19:44,600 --> 00:19:47,030
read to see to the right of X with I too

403
00:19:47,030 --> 00:19:50,169
must come between in in the order

404
00:19:50,169 --> 00:19:52,820
between these two operations so we know

405
00:19:52,820 --> 00:19:55,840
that the read of X 1 must come before

406
00:19:55,840 --> 00:19:59,140
the right of X 2 and that's a cycle

407
00:19:59,140 --> 00:20:03,049
alright so there's no there's no Vinnie

408
00:20:03,049 --> 00:20:06,140
or order or that but there's no linear

409
00:20:06,140 --> 00:20:10,130
order that can obey all of these time

410
00:20:10,130 --> 00:20:14,059
and value rules and there isn't because

411
00:20:14,059 --> 00:20:16,530
there's a cycle in the

412
00:20:16,530 --> 00:20:24,480
in the graph yes

413
00:20:32,870 --> 00:20:35,550
that's a good question this this

414
00:20:35,550 --> 00:20:37,410
definitions the definition about

415
00:20:37,410 --> 00:20:41,070
history's not about necessarily systems

416
00:20:41,070 --> 00:20:43,650
so what it's not saying is that a system

417
00:20:43,650 --> 00:20:46,950
design is linearizable if something

418
00:20:46,950 --> 00:20:50,460
about the design it's really only

419
00:20:50,460 --> 00:20:53,580
history by history so if we don't get to

420
00:20:53,580 --> 00:20:55,710
know how the system operates internally

421
00:20:55,710 --> 00:20:57,450
and the only thing we know is we get to

422
00:20:57,450 --> 00:20:59,520
watch it while it executes then before

423
00:20:59,520 --> 00:21:01,130
we've seen anything we just don't know

424
00:21:01,130 --> 00:21:02,790
right we mean we'll assume it's

425
00:21:02,790 --> 00:21:04,470
linearizable and then we see more and

426
00:21:04,470 --> 00:21:06,810
more sequences of operations this Akash

427
00:21:06,810 --> 00:21:08,550
they're all consistent with linearize

428
00:21:08,550 --> 00:21:10,560
ability they all follow these rules so

429
00:21:10,560 --> 00:21:12,570
you know we believe it's probably this

430
00:21:12,570 --> 00:21:14,340
isn't linearize of all and if we ever

431
00:21:14,340 --> 00:21:15,780
seen one that isn't then we realize it's

432
00:21:15,780 --> 00:21:20,460
not linearizable so this is yeah it's

433
00:21:20,460 --> 00:21:22,110
not a definition on the system design

434
00:21:22,110 --> 00:21:23,880
it's a definition on what the what we

435
00:21:23,880 --> 00:21:25,530
observe the system to do so in that

436
00:21:25,530 --> 00:21:27,020
sense it's maybe a little bit

437
00:21:27,020 --> 00:21:28,830
unsatisfying if you're trying to design

438
00:21:28,830 --> 00:21:30,420
something right there's not a recipe for

439
00:21:30,420 --> 00:21:32,670
how you design you know except in a

440
00:21:32,670 --> 00:21:33,960
trivial sense that if you had a single

441
00:21:33,960 --> 00:21:37,260
server in very simple systems one server

442
00:21:37,260 --> 00:21:40,020
one copy of the data not threaded or

443
00:21:40,020 --> 00:21:42,330
multi-core or anything it's a little bit

444
00:21:42,330 --> 00:21:43,770
hard to build a system that violates

445
00:21:43,770 --> 00:21:46,650
this in a very simple set up but super

446
00:21:46,650 --> 00:21:50,280
easy to violate it in any kind of

447
00:21:50,280 --> 00:21:55,770
distributed system okay so the lesson

448
00:21:55,770 --> 00:21:59,550
from this is that there's only can only

449
00:21:59,550 --> 00:22:04,800
be one order in which the system is

450
00:22:04,800 --> 00:22:07,260
observed to execute the writes all

451
00:22:07,260 --> 00:22:10,350
clients have to see value is consistent

452
00:22:10,350 --> 00:22:13,350
with the system executing the writes in

453
00:22:13,350 --> 00:22:16,460
the same order

454
00:22:18,020 --> 00:22:19,760
here's a very simple history

455
00:22:19,760 --> 00:22:24,380
another example supposing we write acts

456
00:22:24,380 --> 00:22:27,500
with value 1 and then definitely

457
00:22:27,500 --> 00:22:29,330
subsequently in time maybe with another

458
00:22:29,330 --> 00:22:32,210
client another client launches a right

459
00:22:32,210 --> 00:22:34,670
of X with value 2 and sees a response

460
00:22:34,670 --> 00:22:36,170
back from the service saying yes I did

461
00:22:36,170 --> 00:22:38,540
the right and then a third client does a

462
00:22:38,540 --> 00:22:45,800
read of X and gets got you one so this

463
00:22:45,800 --> 00:22:47,630
is a very easy example it's clearly not

464
00:22:47,630 --> 00:22:50,650
linearizable because the time rule means

465
00:22:50,650 --> 00:22:54,230
that the only possible order is the

466
00:22:54,230 --> 00:22:55,970
right of X with 1 the right of X is 2

467
00:22:55,970 --> 00:22:57,860
the read of X with 1 so that has to be

468
00:22:57,860 --> 00:22:59,870
the order and that order clearly

469
00:22:59,870 --> 00:23:01,850
violates this is the only one order that

470
00:23:01,850 --> 00:23:03,620
order clearly violates the second rule

471
00:23:03,620 --> 00:23:06,620
about values that is you know the most

472
00:23:06,620 --> 00:23:08,930
value written by the most recent right

473
00:23:08,930 --> 00:23:10,910
in the owned one order that's possible

474
00:23:10,910 --> 00:23:13,010
is not 1 it's 2 so this is clearly not

475
00:23:13,010 --> 00:23:18,320
linearizable and the reason I'm bringing

476
00:23:18,320 --> 00:23:20,810
it up is because this is the argument

477
00:23:20,810 --> 00:23:23,150
that a linearizable system a strongly

478
00:23:23,150 --> 00:23:25,580
consistent system cannot serve up stale

479
00:23:25,580 --> 00:23:29,780
data right and you know the reason why

480
00:23:29,780 --> 00:23:31,460
this might come up is again you know

481
00:23:31,460 --> 00:23:34,340
maybe you have lots of replicas each you

482
00:23:34,340 --> 00:23:36,320
know maybe haven't seen all the rights

483
00:23:36,320 --> 00:23:37,520
or all the committed rights or something

484
00:23:37,520 --> 00:23:40,460
so maybe there's some maybe all the

485
00:23:40,460 --> 00:23:42,230
replicas have seen this right but only

486
00:23:42,230 --> 00:23:43,850
some replicas have seen this right and

487
00:23:43,850 --> 00:23:45,920
so if you ask a replica that's lagging

488
00:23:45,920 --> 00:23:47,360
behind a little bit it's still gonna

489
00:23:47,360 --> 00:23:50,590
have value 1 for X but nevertheless

490
00:23:50,590 --> 00:23:53,600
clients should never be able to see this

491
00:23:53,600 --> 00:23:57,980
old value in a linearizable system are

492
00:23:57,980 --> 00:24:00,290
there no stale data allowed no still

493
00:24:00,290 --> 00:24:02,530
reads

494
00:24:21,510 --> 00:24:23,860
yeah if there's overlap in the interval

495
00:24:23,860 --> 00:24:26,140
then there's then you know that you

496
00:24:26,140 --> 00:24:29,050
could the system could legally execute

497
00:24:29,050 --> 00:24:31,150
either of them in a real-time and I in

498
00:24:31,150 --> 00:24:32,800
the interval so that's the sense in

499
00:24:32,800 --> 00:24:35,950
which they could system gonna execute

500
00:24:35,950 --> 00:24:38,070
them in either order now you know other

501
00:24:38,070 --> 00:24:40,180
you know if it weren't for these two

502
00:24:40,180 --> 00:24:43,440
reads the system would have you know

503
00:24:43,440 --> 00:24:45,490
total freedom execute that writes in

504
00:24:45,490 --> 00:24:47,440
either order but because we saw the two

505
00:24:47,440 --> 00:24:52,690
reads we know that you know the only

506
00:24:52,690 --> 00:25:01,990
legal order is two and then one yeah so

507
00:25:01,990 --> 00:25:03,310
if the two reserva laughing then and

508
00:25:03,310 --> 00:25:04,690
then any order then the reads could have

509
00:25:04,690 --> 00:25:07,150
seen either in fact you know Toby saw

510
00:25:07,150 --> 00:25:08,320
the two and the one words all from the

511
00:25:08,320 --> 00:25:11,250
reads these doobies could have you know

512
00:25:11,250 --> 00:25:13,570
the system until it committed to the

513
00:25:13,570 --> 00:25:15,430
values for the read it still had freedom

514
00:25:15,430 --> 00:25:18,450
to return them in either order

515
00:25:23,669 --> 00:25:28,780
I'm using them as synonyms yeah yeah you

516
00:25:28,780 --> 00:25:31,480
know for most people although possibly

517
00:25:31,480 --> 00:25:34,660
not today's paper linearize ability is

518
00:25:34,660 --> 00:25:37,900
is well defined and and people's

519
00:25:37,900 --> 00:25:39,460
definitions really deviate very much

520
00:25:39,460 --> 00:25:43,750
from this strong consistency though is

521
00:25:43,750 --> 00:25:45,700
less I think there's less sort of

522
00:25:45,700 --> 00:25:47,890
consensus about exactly what the

523
00:25:47,890 --> 00:25:49,690
definition might be if you meant strong

524
00:25:49,690 --> 00:25:53,200
consistency it's often men it's usually

525
00:25:53,200 --> 00:25:55,120
men too in ways that are quite close to

526
00:25:55,120 --> 00:25:55,780
this

527
00:25:55,780 --> 00:25:57,850
like for example that oh the system

528
00:25:57,850 --> 00:26:00,640
behaves the same way that a system with

529
00:26:00,640 --> 00:26:02,590
only one copy of the data would behave

530
00:26:02,590 --> 00:26:05,169
all right which is quite close to what

531
00:26:05,169 --> 00:26:06,220
we're getting at with this definition

532
00:26:06,220 --> 00:26:10,150
but yeah for you know it's reasonable to

533
00:26:10,150 --> 00:26:12,070
assume that strong strong consistency is

534
00:26:12,070 --> 00:26:18,450
the same as serializable okay so this is

535
00:26:18,450 --> 00:26:21,400
not linearizable and the you know the

536
00:26:21,400 --> 00:26:26,350
the lesson is weeds are not allowed to

537
00:26:26,350 --> 00:26:29,830
return stale data only only fresh data

538
00:26:29,830 --> 00:26:33,100
or you can only return the results of

539
00:26:33,100 --> 00:26:37,110
the most recently completed right

540
00:26:44,700 --> 00:26:51,610
okay I have a final final little example

541
00:26:51,610 --> 00:26:54,660
so we have two clients one of them

542
00:26:54,660 --> 00:26:58,060
submits a write to X with value three

543
00:26:58,060 --> 00:27:04,450
and then write two acts with value 4 and

544
00:27:04,450 --> 00:27:07,930
we have another client and you know at

545
00:27:07,930 --> 00:27:10,630
this point in time the client issues a

546
00:27:10,630 --> 00:27:15,550
read of X but and this is a question you

547
00:27:15,550 --> 00:27:18,520
asked the the client doesn't get a

548
00:27:18,520 --> 00:27:21,910
response right you know who knows like

549
00:27:21,910 --> 00:27:23,680
it in the sort of actual implementation

550
00:27:23,680 --> 00:27:25,420
may be the leader crashed at some point

551
00:27:25,420 --> 00:27:27,790
maybe the his client to sent in the read

552
00:27:27,790 --> 00:27:29,890
request so the leader maybe didn't get

553
00:27:29,890 --> 00:27:31,840
it because the request was dropped or

554
00:27:31,840 --> 00:27:34,540
maybe the leader got the request and

555
00:27:34,540 --> 00:27:36,700
executed it but the response the network

556
00:27:36,700 --> 00:27:38,890
dropped the response or maybe the leader

557
00:27:38,890 --> 00:27:40,870
got it and started to process up and

558
00:27:40,870 --> 00:27:42,700
then crash before finished processing

559
00:27:42,700 --> 00:27:44,680
and or maybe did process it and crash

560
00:27:44,680 --> 00:27:45,940
before saying the response who knows

561
00:27:45,940 --> 00:27:48,160
when the clients point of view like sent

562
00:27:48,160 --> 00:27:50,140
a request and never got a response so in

563
00:27:50,140 --> 00:27:52,300
the interior machinery of the client for

564
00:27:52,300 --> 00:27:53,650
most of the systems we're talking about

565
00:27:53,650 --> 00:27:55,030
the client is going to resend the

566
00:27:55,030 --> 00:27:57,700
request maybe do a different leader

567
00:27:57,700 --> 00:27:59,800
maybe the same leader who knows what so

568
00:27:59,800 --> 00:28:01,950
it sent the first question quest here

569
00:28:01,950 --> 00:28:05,470
and maybe it sends the second request at

570
00:28:05,470 --> 00:28:07,150
this point in time it times out you know

571
00:28:07,150 --> 00:28:10,450
no response sends the second request at

572
00:28:10,450 --> 00:28:12,760
this point and then finally gets a

573
00:28:12,760 --> 00:28:19,390
response it turns out that and you're

574
00:28:19,390 --> 00:28:22,320
going to implement this in lab 3 that a

575
00:28:22,320 --> 00:28:26,830
reasonable way of servers dealing with

576
00:28:26,830 --> 00:28:28,360
repeated requests is for their servers

577
00:28:28,360 --> 00:28:31,540
to keep tables sort of indexed by some

578
00:28:31,540 --> 00:28:32,920
kind of unique request number or

579
00:28:32,920 --> 00:28:35,080
something from the clients in which the

580
00:28:35,080 --> 00:28:36,400
servers remember oh I already saw that

581
00:28:36,400 --> 00:28:38,890
request and executed it and this was the

582
00:28:38,890 --> 00:28:41,110
response that I sent back because you

583
00:28:41,110 --> 00:28:42,690
don't want to execute a request twice

584
00:28:42,690 --> 00:28:45,400
you know if it's a for example if it's a

585
00:28:45,400 --> 00:28:47,410
write request you don't want to execute

586
00:28:47,410 --> 00:28:49,300
requests right so the server's have to

587
00:28:49,300 --> 00:28:51,000
be able to filter out duplicate requests

588
00:28:51,000 --> 00:28:53,950
and they have to be able to return the

589
00:28:53,950 --> 00:28:56,020
reply to repeat the reply that the

590
00:28:56,020 --> 00:28:57,130
originally

591
00:28:57,130 --> 00:28:59,049
sent to that request which perhaps has

592
00:28:59,049 --> 00:29:00,730
dropped by the network so that servers

593
00:29:00,730 --> 00:29:04,559
remember the original pry and repeat it

594
00:29:04,559 --> 00:29:07,870
in response to the resend and if you do

595
00:29:07,870 --> 00:29:12,580
that which you will in lab 3 then if you

596
00:29:12,580 --> 00:29:16,299
know since the server the leader could

597
00:29:16,299 --> 00:29:18,400
have seen value 3 when it executed the

598
00:29:18,400 --> 00:29:20,799
original read request from client to it

599
00:29:20,799 --> 00:29:23,860
could return value 3 to the repeated

600
00:29:23,860 --> 00:29:25,870
requests that was sent at this time and

601
00:29:25,870 --> 00:29:30,460
completed at this time and so we have to

602
00:29:30,460 --> 00:29:33,450
make a call on whether that is legal

603
00:29:33,450 --> 00:29:38,020
right you could argue that oh gosh you

604
00:29:38,020 --> 00:29:39,640
know the client we sent the request here

605
00:29:39,640 --> 00:29:41,169
this was after the right of X 2 4

606
00:29:41,169 --> 00:29:42,429
completed so Jesus what you really

607
00:29:42,429 --> 00:29:44,679
should return for at this point instead

608
00:29:44,679 --> 00:29:52,020
of 3 and this is like a little bit a

609
00:29:52,020 --> 00:29:55,150
question of it's like a little bit up

610
00:29:55,150 --> 00:29:58,510
the designer but if what you view is

611
00:29:58,510 --> 00:30:00,460
going on is that the retransmissions are

612
00:30:00,460 --> 00:30:05,080
a low-level concern that's you know part

613
00:30:05,080 --> 00:30:07,120
of the RPC machinery or hidden in some

614
00:30:07,120 --> 00:30:08,679
library or something and that from the

615
00:30:08,679 --> 00:30:10,750
client applications point of view all

616
00:30:10,750 --> 00:30:12,730
that happened was that it's sent a

617
00:30:12,730 --> 00:30:15,039
request at this time and got a response

618
00:30:15,039 --> 00:30:17,289
at this time and that's all that

619
00:30:17,289 --> 00:30:18,520
happened from the clients point of view

620
00:30:18,520 --> 00:30:21,669
then a value of 3 is totally legal here

621
00:30:21,669 --> 00:30:24,150
because this request took a long time

622
00:30:24,150 --> 00:30:26,350
it's completely concurrent with the

623
00:30:26,350 --> 00:30:28,780
right not ordered in real time with the

624
00:30:28,780 --> 00:30:31,900
right and therefore either the three or

625
00:30:31,900 --> 00:30:34,330
the four is valid you know as if the

626
00:30:34,330 --> 00:30:36,490
read requests that really executed here

627
00:30:36,490 --> 00:30:39,309
in real time or or here in real time so

628
00:30:39,309 --> 00:30:42,730
the larger lesson is if you have client

629
00:30:42,730 --> 00:30:47,320
retransmissions the from the application

630
00:30:47,320 --> 00:30:48,669
point of view if you're defining

631
00:30:48,669 --> 00:30:50,470
linearize ability from the applications

632
00:30:50,470 --> 00:30:53,350
point of view - even with

633
00:30:53,350 --> 00:30:56,200
retransmissions the real time extent of

634
00:30:56,200 --> 00:30:59,380
the requests like this is from the very

635
00:30:59,380 --> 00:31:01,240
first transmission of the requests to

636
00:31:01,240 --> 00:31:03,340
the final time at which the application

637
00:31:03,340 --> 00:31:05,710
actually got the response maybe after

638
00:31:05,710 --> 00:31:10,110
many reasons yes

639
00:31:24,790 --> 00:31:27,590
you might rather you got fresh data than

640
00:31:27,590 --> 00:31:30,560
stale data you know if I'm you know

641
00:31:30,560 --> 00:31:32,360
supposing the request is what time it

642
00:31:32,360 --> 00:31:34,520
what time is it that's a time server I

643
00:31:34,520 --> 00:31:35,990
sent a request saying Oh what time is it

644
00:31:35,990 --> 00:31:38,570
and it sends me a response you know yeah

645
00:31:38,570 --> 00:31:40,400
if I send a request now and I don't get

646
00:31:40,400 --> 00:31:42,980
the response until 2 minutes from now

647
00:31:42,980 --> 00:31:46,550
dude some Network issue it may be that

648
00:31:46,550 --> 00:31:48,920
the application would like prefer to see

649
00:31:48,920 --> 00:31:50,840
we're gonna get the response it would

650
00:31:50,840 --> 00:31:53,510
prefer to see a time that was close to

651
00:31:53,510 --> 00:31:54,590
the time at which had actually got the

652
00:31:54,590 --> 00:31:56,750
response rather than a time deep in the

653
00:31:56,750 --> 00:31:58,190
past when it originally sent the request

654
00:31:58,190 --> 00:32:02,720
now the fact is that if you you know if

655
00:32:02,720 --> 00:32:03,980
you're using a system like this you have

656
00:32:03,980 --> 00:32:05,300
to write applications that are tolerant

657
00:32:05,300 --> 00:32:09,470
of these rules you're using a

658
00:32:09,470 --> 00:32:11,240
linearizable system like these are the

659
00:32:11,240 --> 00:32:13,730
rules and so you must write you know

660
00:32:13,730 --> 00:32:15,880
correct applications must be tolerant of

661
00:32:15,880 --> 00:32:17,900
you know if they send a request and they

662
00:32:17,900 --> 00:32:19,340
get a response a while later they just

663
00:32:19,340 --> 00:32:22,340
you know you can't are not allowed to

664
00:32:22,340 --> 00:32:25,190
write the application as if oh gosh if I

665
00:32:25,190 --> 00:32:27,290
get a response that means that the value

666
00:32:27,290 --> 00:32:30,080
at the time I got the response was equal

667
00:32:30,080 --> 00:32:32,240
to 3 that is not OK for applications to

668
00:32:32,240 --> 00:32:34,280
think you know what that I have that

669
00:32:34,280 --> 00:32:35,380
plays out for a given application

670
00:32:35,380 --> 00:32:40,390
depends on what the application is doing

671
00:32:40,600 --> 00:32:42,560
the reason I bring this up is because

672
00:32:42,560 --> 00:32:45,530
it's a common question in 6 6 8 to 4 you

673
00:32:45,530 --> 00:32:47,780
guys will implement the machinery by

674
00:32:47,780 --> 00:32:51,080
which servers detect duplicates and

675
00:32:51,080 --> 00:32:56,180
resend the previous answer that the

676
00:32:56,180 --> 00:32:57,500
server originally sent and the question

677
00:32:57,500 --> 00:33:00,800
will come up is it ok if you originally

678
00:33:00,800 --> 00:33:02,810
saw the request here to return at this

679
00:33:02,810 --> 00:33:05,450
point in time the response that you

680
00:33:05,450 --> 00:33:08,060
would have sent back here if the network

681
00:33:08,060 --> 00:33:11,720
hadn't dropped it and it's it's handy to

682
00:33:11,720 --> 00:33:13,910
have a kind of way of reasoning I mean

683
00:33:13,910 --> 00:33:15,020
one reason to have definitions like

684
00:33:15,020 --> 00:33:16,400
linearize abilities to be able to reason

685
00:33:16,400 --> 00:33:18,290
about questions like that right i'm

686
00:33:18,290 --> 00:33:21,920
using using this scheme we can say well

687
00:33:21,920 --> 00:33:25,480
it actually is okay by those rules

688
00:33:26,210 --> 00:33:28,080
all right that's all i want to say about

689
00:33:28,080 --> 00:33:32,010
linearize ability of any any lingering

690
00:33:32,010 --> 00:33:35,810
questions yeah

691
00:33:45,230 --> 00:33:49,039
well you know maybe I'm taking liberties

692
00:33:49,039 --> 00:33:55,460
here but what's going on is that in real

693
00:33:55,460 --> 00:33:57,620
time we have a read of - and a read of

694
00:33:57,620 --> 00:33:59,899
one and the read of one really came

695
00:33:59,899 --> 00:34:01,730
after in real time the read of two and

696
00:34:01,730 --> 00:34:04,519
so must come must be in this order in

697
00:34:04,519 --> 00:34:07,580
the final order that means there must

698
00:34:07,580 --> 00:34:11,449
have been a right of - somewhere in here

699
00:34:11,449 --> 00:34:13,129
it's our right with value one somewhere

700
00:34:13,129 --> 00:34:15,770
in here that is after the read of - in

701
00:34:15,770 --> 00:34:17,780
the final order right after the read of

702
00:34:17,780 --> 00:34:20,449
- and before the read of one in that

703
00:34:20,449 --> 00:34:22,040
order there must be a right with value

704
00:34:22,040 --> 00:34:23,869
one there's only one right with a value

705
00:34:23,869 --> 00:34:25,339
unavailable you know if there were more

706
00:34:25,339 --> 00:34:27,079
than one we maybe could play games but

707
00:34:27,079 --> 00:34:29,300
there's only one available so this right

708
00:34:29,300 --> 00:34:31,790
must slip in here in the final order or

709
00:34:31,790 --> 00:34:38,770
therefore I felt able to draw this arrow

710
00:34:38,770 --> 00:34:42,139
and these arrows just capture the sort

711
00:34:42,139 --> 00:34:44,179
of one by one implication of the rules

712
00:34:44,179 --> 00:34:50,290
on what the order must look like yeah

713
00:35:02,490 --> 00:35:06,820
all right yeah I mean any hour or X so

714
00:35:06,820 --> 00:35:16,560
which sorry which which yeah his own rx1

715
00:35:16,560 --> 00:35:19,960
he sees it before his own rx1 okay so

716
00:35:19,960 --> 00:35:32,790
the via yep well we're not we're not

717
00:35:32,790 --> 00:35:35,890
we're not really able to say which of

718
00:35:35,890 --> 00:35:39,580
these two wheats came first so we can't

719
00:35:39,580 --> 00:35:41,470
quite for all this error if we mean this

720
00:35:41,470 --> 00:35:43,810
arrow to constrain the ultimate order

721
00:35:43,810 --> 00:35:46,300
we're not you know the these two weeds

722
00:35:46,300 --> 00:35:48,220
could come in either order so we're not

723
00:35:48,220 --> 00:35:49,690
allowed to say this one came before that

724
00:35:49,690 --> 00:35:52,420
one it could be there's a simpler cycle

725
00:35:52,420 --> 00:35:55,300
actually then I've drawn so I mean it

726
00:35:55,300 --> 00:35:58,360
may be because certainly the that the

727
00:35:58,360 --> 00:36:02,560
damage is in these four items I agree

728
00:36:02,560 --> 00:36:05,380
with that these two these four items

729
00:36:05,380 --> 00:36:08,860
kind of are the main evidence that

730
00:36:08,860 --> 00:36:09,700
something is wrong

731
00:36:09,700 --> 00:36:11,860
now whether a cycle I'm not sure whether

732
00:36:11,860 --> 00:36:13,240
there's a cycle that just involves that

733
00:36:13,240 --> 00:36:16,930
there could be okay this is worth

734
00:36:16,930 --> 00:36:19,540
thinking about cuz you know if I can't

735
00:36:19,540 --> 00:36:20,440
think of anything better or I'll

736
00:36:20,440 --> 00:36:21,460
certainly ask you a question about

737
00:36:21,460 --> 00:36:27,240
linearizable histories on midterm

738
00:36:31,010 --> 00:36:36,740
okay so today's paper today's paper

739
00:36:36,740 --> 00:36:43,670
zookeeper and I mean part of the reason

740
00:36:43,670 --> 00:36:45,109
we're even zookeeper paper is that it's

741
00:36:45,109 --> 00:36:46,790
a successful real world system it's an

742
00:36:46,790 --> 00:36:50,660
open source you know service that

743
00:36:50,660 --> 00:36:51,920
actually a lot of people ron has been

744
00:36:51,920 --> 00:36:53,510
incorporated into a lot of real world

745
00:36:53,510 --> 00:36:55,460
software so there's a certain kind of

746
00:36:55,460 --> 00:36:59,780
reality and success to it but you know

747
00:36:59,780 --> 00:37:00,890
that makes attractive from the point of

748
00:37:00,890 --> 00:37:04,310
view of kind of supporting the idea that

749
00:37:04,310 --> 00:37:05,660
the zookeepers design might actually be

750
00:37:05,660 --> 00:37:08,210
a reasonable design but the reason we're

751
00:37:08,210 --> 00:37:10,220
interested in in it I'm interested in it

752
00:37:10,220 --> 00:37:12,410
is for to somewhat more precise

753
00:37:12,410 --> 00:37:18,320
technical points so why are we looking

754
00:37:18,320 --> 00:37:23,090
at this paper so one of them is that in

755
00:37:23,090 --> 00:37:25,520
contrast to raft like the raft you've

756
00:37:25,520 --> 00:37:27,350
written and raft as that's defined it's

757
00:37:27,350 --> 00:37:29,180
really a library you know you can use a

758
00:37:29,180 --> 00:37:31,670
raft library as a part of some larger

759
00:37:31,670 --> 00:37:34,400
replicated system but raft isn't like a

760
00:37:34,400 --> 00:37:36,440
standalone service or something that you

761
00:37:36,440 --> 00:37:38,330
can talk to it's you really have to

762
00:37:38,330 --> 00:37:40,430
design your application to interact at

763
00:37:40,430 --> 00:37:45,170
the raft library explicitly so you might

764
00:37:45,170 --> 00:37:46,820
wonder it's an interesting question

765
00:37:46,820 --> 00:37:52,060
whether some useful system sort of

766
00:37:52,060 --> 00:37:54,530
standalone general-purpose system could

767
00:37:54,530 --> 00:37:56,600
be defined that would be helpful for

768
00:37:56,600 --> 00:37:59,240
people building separate distributed

769
00:37:59,240 --> 00:38:00,920
systems like is there serve some service

770
00:38:00,920 --> 00:38:02,780
that can bite off a significant portion

771
00:38:02,780 --> 00:38:04,520
of why it's painful to build distributed

772
00:38:04,520 --> 00:38:06,440
systems and sort of package it up in a

773
00:38:06,440 --> 00:38:09,140
standalone service that you know anybody

774
00:38:09,140 --> 00:38:14,090
can use so this is really the question

775
00:38:14,090 --> 00:38:16,730
of what would an API look like for a

776
00:38:16,730 --> 00:38:24,230
general purpose I'll call it I'm not

777
00:38:24,230 --> 00:38:25,670
sure what the right name for things like

778
00:38:25,670 --> 00:38:27,740
zookeeper is but you've got a general

779
00:38:27,740 --> 00:38:32,200
purpose coordination service

780
00:38:33,930 --> 00:38:37,480
and the other question the other

781
00:38:37,480 --> 00:38:41,760
interesting aspect of zookeeper is that

782
00:38:41,760 --> 00:38:44,079
when we build replicated systems and

783
00:38:44,079 --> 00:38:45,460
zookeepers a replicated system because

784
00:38:45,460 --> 00:38:47,260
among other things it's it's like a

785
00:38:47,260 --> 00:38:48,630
fault-tolerant

786
00:38:48,630 --> 00:38:51,609
general-purpose coordination service and

787
00:38:51,609 --> 00:38:53,500
it gets fault tolerance like most

788
00:38:53,500 --> 00:38:55,599
systems by replication that is there's a

789
00:38:55,599 --> 00:38:57,579
bunch of you know maybe three or five or

790
00:38:57,579 --> 00:38:58,780
seven or who knows what

791
00:38:58,780 --> 00:39:03,039
zookeeper servers it takes money to buy

792
00:39:03,039 --> 00:39:05,049
those servers right like a 7 server

793
00:39:05,049 --> 00:39:09,160
zookeeper setup is 7 times expensive as

794
00:39:09,160 --> 00:39:13,510
a sort of simple single server so it's

795
00:39:13,510 --> 00:39:16,240
very tempting to ask if you buy 7

796
00:39:16,240 --> 00:39:17,920
servers to run your replicated service

797
00:39:17,920 --> 00:39:20,319
can you get 7 times the performance out

798
00:39:20,319 --> 00:39:24,010
of your 7 servers right and you know how

799
00:39:24,010 --> 00:39:29,109
could we possibly do that so the

800
00:39:29,109 --> 00:39:31,900
question is you know we have n times as

801
00:39:31,900 --> 00:39:35,530
many servers can that yield us n times

802
00:39:35,530 --> 00:39:42,190
the performance so I'm gonna talk about

803
00:39:42,190 --> 00:39:46,450
the second question first so from the

804
00:39:46,450 --> 00:39:47,529
point of view this discussion about

805
00:39:47,529 --> 00:39:50,799
performance I'm just going to view

806
00:39:50,799 --> 00:39:53,140
zookeeper as just some service we don't

807
00:39:53,140 --> 00:39:54,609
really care what the service is but

808
00:39:54,609 --> 00:39:57,579
replicated with a raft like replication

809
00:39:57,579 --> 00:39:59,470
system zookeeper actually runs on top of

810
00:39:59,470 --> 00:40:03,069
this thing called Zab which for our

811
00:40:03,069 --> 00:40:05,220
purposes

812
00:40:06,320 --> 00:40:09,480
we'll just treat as being almost

813
00:40:09,480 --> 00:40:14,849
identical to the raft and I'm just

814
00:40:14,849 --> 00:40:15,990
worried about the performance of the

815
00:40:15,990 --> 00:40:17,640
replication I'm not really worried about

816
00:40:17,640 --> 00:40:20,160
what zookeepers specifically is up to so

817
00:40:20,160 --> 00:40:22,140
the general picture is that you know we

818
00:40:22,140 --> 00:40:24,240
have a bunch of clients maybe hundreds

819
00:40:24,240 --> 00:40:27,840
maybe hundreds of clients and we have

820
00:40:27,840 --> 00:40:35,400
just as in the lads we have a leader the

821
00:40:35,400 --> 00:40:37,740
leader has a zookeeper layer that

822
00:40:37,740 --> 00:40:39,810
clients talk to and then under the

823
00:40:39,810 --> 00:40:42,510
zookeeper layer is the zab system that

824
00:40:42,510 --> 00:40:44,730
manages replication then just like rafts

825
00:40:44,730 --> 00:40:47,190
what was a a lot of what's that is doing

826
00:40:47,190 --> 00:40:49,859
is maintaining a log that contains the

827
00:40:49,859 --> 00:40:51,510
sequence of operations that clients have

828
00:40:51,510 --> 00:40:57,930
sent in really very similar to raft may

829
00:40:57,930 --> 00:41:01,500
have a bunch of these and each of them

830
00:41:01,500 --> 00:41:09,380
has a log but it's a pending new request

831
00:41:10,369 --> 00:41:15,410
that's a familiar set up so the

832
00:41:15,410 --> 00:41:18,119
Clinton's in a request and the Zab layer

833
00:41:18,119 --> 00:41:21,830
you know sends a copy of that request to

834
00:41:21,830 --> 00:41:24,210
each of the replicas and the replicas

835
00:41:24,210 --> 00:41:25,440
append this to their in-memory law I'd

836
00:41:25,440 --> 00:41:28,440
probably persisted onto a disk so they

837
00:41:28,440 --> 00:41:29,520
can get it back if they crash and

838
00:41:29,520 --> 00:41:35,190
restart so the question is as we add

839
00:41:35,190 --> 00:41:36,660
more servers you know we could have four

840
00:41:36,660 --> 00:41:38,490
servers or five or seven or whatever

841
00:41:38,490 --> 00:41:41,099
does the system get faster as we add

842
00:41:41,099 --> 00:41:48,960
more more CPUs more horsepower to it do

843
00:41:48,960 --> 00:41:50,430
you think your labs will get faster as

844
00:41:50,430 --> 00:41:53,820
you have more replicas assuming they're

845
00:41:53,820 --> 00:41:56,070
each replicas its own computer right so

846
00:41:56,070 --> 00:41:58,020
that you really do get more CPU cycles

847
00:41:58,020 --> 00:42:00,980
as you add more revenues

848
00:42:09,440 --> 00:42:12,829
between all the

849
00:42:17,280 --> 00:42:19,330
yeah yeah there's nothing about this

850
00:42:19,330 --> 00:42:20,530
that makes it faster as you add more

851
00:42:20,530 --> 00:42:23,110
servers right it's absolutely true like

852
00:42:23,110 --> 00:42:25,780
as we have more servers you know the

853
00:42:25,780 --> 00:42:27,100
leader is almost certainly a bottleneck

854
00:42:27,100 --> 00:42:28,330
cuz the leader has to process every

855
00:42:28,330 --> 00:42:30,130
request and it sends a copy of every

856
00:42:30,130 --> 00:42:31,630
request to every other server as you add

857
00:42:31,630 --> 00:42:33,760
more servers it just adds more work to

858
00:42:33,760 --> 00:42:36,220
this bottleneck node right you're not

859
00:42:36,220 --> 00:42:37,720
getting any benefit any performance

860
00:42:37,720 --> 00:42:39,070
benefit out of the added servers because

861
00:42:39,070 --> 00:42:40,120
they're not really doing anything

862
00:42:40,120 --> 00:42:42,910
they're just all happily doing whatever

863
00:42:42,910 --> 00:42:45,930
the leader tells them to do they're not

864
00:42:45,930 --> 00:42:48,160
you know subtracting from the leaders

865
00:42:48,160 --> 00:42:50,200
work and every single operation goes to

866
00:42:50,200 --> 00:42:54,220
the leader so for here you know the

867
00:42:54,220 --> 00:42:56,020
performance is you know inversely

868
00:42:56,020 --> 00:42:58,300
proportional to the number of servers

869
00:42:58,300 --> 00:42:59,590
that you add you add more servers this

870
00:42:59,590 --> 00:43:02,350
almost certainly gets lower because the

871
00:43:02,350 --> 00:43:04,780
leader just has more work so in this

872
00:43:04,780 --> 00:43:06,790
system we have the problem that more

873
00:43:06,790 --> 00:43:15,370
servers makes the system slower that's

874
00:43:15,370 --> 00:43:16,720
too bad you know these servers cost a

875
00:43:16,720 --> 00:43:18,370
couple thousand bucks each and you would

876
00:43:18,370 --> 00:43:20,320
hope that you could use them to get

877
00:43:20,320 --> 00:43:25,650
better performance yeah

878
00:43:33,040 --> 00:43:35,710
okay so the question is what if the

879
00:43:35,710 --> 00:43:38,080
requests may be from different clients

880
00:43:38,080 --> 00:43:39,610
or successive requests and same client

881
00:43:39,610 --> 00:43:41,500
or something what if the requests apply

882
00:43:41,500 --> 00:43:43,450
two totally different parts of the state

883
00:43:43,450 --> 00:43:45,340
so you know in a key value store maybe

884
00:43:45,340 --> 00:43:46,960
one of them is a put on X and the other

885
00:43:46,960 --> 00:43:48,730
was a put on Y like nothing to do with

886
00:43:48,730 --> 00:43:52,270
each other you know can we take

887
00:43:52,270 --> 00:43:55,000
advantage of that and the answer that is

888
00:43:55,000 --> 00:43:57,790
absolutely now not in this framework

889
00:43:57,790 --> 00:44:00,790
though or it's the center which we can

890
00:44:00,790 --> 00:44:02,470
take advantage of it it's very limited

891
00:44:02,470 --> 00:44:06,370
in this framework it could be well at a

892
00:44:06,370 --> 00:44:08,710
high level the leader the requests all

893
00:44:08,710 --> 00:44:11,920
still go through the leader and the

894
00:44:11,920 --> 00:44:13,390
leader still has to send it out to all

895
00:44:13,390 --> 00:44:15,160
the replicas and the more replicas there

896
00:44:15,160 --> 00:44:17,200
are the more messages the leader has to

897
00:44:17,200 --> 00:44:19,990
send so at a high level it's not likely

898
00:44:19,990 --> 00:44:23,890
to this sort of commutative or community

899
00:44:23,890 --> 00:44:25,420
of requests is not likely to help this

900
00:44:25,420 --> 00:44:28,120
situation is a fantastic thought to keep

901
00:44:28,120 --> 00:44:29,500
in mind though because it'll absolutely

902
00:44:29,500 --> 00:44:32,890
come up in other systems and people will

903
00:44:32,890 --> 00:44:34,270
be able to take advantage of it in other

904
00:44:34,270 --> 00:44:39,730
systems okay so so there's a little bit

905
00:44:39,730 --> 00:44:41,560
disappointing facts with server hardware

906
00:44:41,560 --> 00:44:48,540
wasn't helping performance so a very

907
00:44:48,540 --> 00:44:52,300
sort of obvious maybe the simplest way

908
00:44:52,300 --> 00:44:54,550
that you might be able to harness these

909
00:44:54,550 --> 00:44:57,430
other servers is build a system in which

910
00:44:57,430 --> 00:44:59,860
ya write requests all have to go through

911
00:44:59,860 --> 00:45:03,220
the leader but in the real world a huge

912
00:45:03,220 --> 00:45:05,380
number of workloads are read heavy that

913
00:45:05,380 --> 00:45:06,700
is there's many more reads like when you

914
00:45:06,700 --> 00:45:07,960
look at web pages you know it's all

915
00:45:07,960 --> 00:45:09,970
about reading data to produce the web

916
00:45:09,970 --> 00:45:11,740
page and generally there are very

917
00:45:11,740 --> 00:45:13,660
relatively few rights and that's true of

918
00:45:13,660 --> 00:45:15,070
a lot of systems so maybe we'll send

919
00:45:15,070 --> 00:45:18,310
rights to the leader but send weeds just

920
00:45:18,310 --> 00:45:21,640
to one of the replicas right just pick

921
00:45:21,640 --> 00:45:22,840
one of the replicas and if you have a

922
00:45:22,840 --> 00:45:24,940
read-only request like a get in lab 3

923
00:45:24,940 --> 00:45:26,200
just send it to one of the replicas and

924
00:45:26,200 --> 00:45:29,350
not to the leader now if we do that we

925
00:45:29,350 --> 00:45:30,520
haven't helped rights much although

926
00:45:30,520 --> 00:45:32,020
we've gotten a lot of read workload off

927
00:45:32,020 --> 00:45:33,700
the leader so maybe that helps but we

928
00:45:33,700 --> 00:45:36,400
absolutely have made tremendous progress

929
00:45:36,400 --> 00:45:38,560
with reads because now the more servers

930
00:45:38,560 --> 00:45:42,550
we add the more clients we can support

931
00:45:42,550 --> 00:45:44,080
right because we're just splitting the

932
00:45:44,080 --> 00:45:45,390
client lead work

933
00:45:45,390 --> 00:45:48,180
across the different replicas so the

934
00:45:48,180 --> 00:45:51,930
question is if we have clients send

935
00:45:51,930 --> 00:45:55,710
directly to the replicas are we going to

936
00:45:55,710 --> 00:45:58,100
be happy

937
00:46:07,270 --> 00:46:10,450
yeah so up-to-date does the right is the

938
00:46:10,450 --> 00:46:13,119
right word in a raft like system which

939
00:46:13,119 --> 00:46:17,970
zookeeper is if a client sends a request

940
00:46:17,970 --> 00:46:20,800
to a random replica you know sure the

941
00:46:20,800 --> 00:46:22,869
replica you know has a copy the log in

942
00:46:22,869 --> 00:46:24,940
it you know it's been executing along

943
00:46:24,940 --> 00:46:26,950
with the leader and you know for lab 3

944
00:46:26,950 --> 00:46:29,530
it's got this key value table and you

945
00:46:29,530 --> 00:46:31,990
know you do a get for key X and it's

946
00:46:31,990 --> 00:46:34,510
gonna have some four key exodus table

947
00:46:34,510 --> 00:46:36,099
and it can reply to you so sort of

948
00:46:36,099 --> 00:46:38,980
functionally the replicas got all the

949
00:46:38,980 --> 00:46:40,869
pieces it needs to respond to client to

950
00:46:40,869 --> 00:46:44,260
read requests from clients the

951
00:46:44,260 --> 00:46:47,109
difficulty is that there's no reason to

952
00:46:47,109 --> 00:46:49,300
believe that anyone replicas other than

953
00:46:49,300 --> 00:46:54,130
the leader is up to date because well

954
00:46:54,130 --> 00:46:56,080
there's a bunch of reasons why why

955
00:46:56,080 --> 00:46:57,880
replicas may not be up to date one of

956
00:46:57,880 --> 00:46:59,650
them is that they may not be in the

957
00:46:59,650 --> 00:47:02,230
majority that the leader was waiting for

958
00:47:02,230 --> 00:47:04,089
you think about what raft is doing the

959
00:47:04,089 --> 00:47:05,740
leader is only obliged to wait for

960
00:47:05,740 --> 00:47:07,599
responses to its append entries from a

961
00:47:07,599 --> 00:47:10,599
majority of the followers and then it

962
00:47:10,599 --> 00:47:11,950
can commit the operation and go on to

963
00:47:11,950 --> 00:47:14,260
the next operation so if this replica

964
00:47:14,260 --> 00:47:16,330
wasn't in the majority it may never have

965
00:47:16,330 --> 00:47:18,790
seen a riot it may be the network

966
00:47:18,790 --> 00:47:20,950
dropped it and never got it and so yeah

967
00:47:20,950 --> 00:47:25,530
you know the leader and you know a

968
00:47:25,530 --> 00:47:27,820
majority of the servers have seen the

969
00:47:27,820 --> 00:47:30,000
first three requests but you know this

970
00:47:30,000 --> 00:47:31,990
server only saw the first two it's

971
00:47:31,990 --> 00:47:35,260
missing B so read to be a read of you

972
00:47:35,260 --> 00:47:37,300
know what should be there I'll just be

973
00:47:37,300 --> 00:47:40,740
totally get a stale value from this one

974
00:47:40,740 --> 00:47:45,490
even if this replica actually saw this

975
00:47:45,490 --> 00:47:47,320
new log entry it might be missing the

976
00:47:47,320 --> 00:47:50,260
commit command you know this zookeepers

977
00:47:50,260 --> 00:47:52,180
app as much the same as raft it first

978
00:47:52,180 --> 00:47:54,339
sends out a log entry and then when the

979
00:47:54,339 --> 00:47:55,780
leader gets a majority of positive

980
00:47:55,780 --> 00:47:57,220
replies the leader sends out a

981
00:47:57,220 --> 00:47:58,930
notification saying yeah I'm gonna

982
00:47:58,930 --> 00:48:01,150
committing that log entry I may not have

983
00:48:01,150 --> 00:48:03,280
gotten the commit and the sort of worst

984
00:48:03,280 --> 00:48:04,540
case version of this although its

985
00:48:04,540 --> 00:48:05,920
equivalent to what I already said is

986
00:48:05,920 --> 00:48:08,650
that for all this client for all client

987
00:48:08,650 --> 00:48:14,349
to knows this replica may be partitioned

988
00:48:14,349 --> 00:48:16,000
from the leader or may just absolutely

989
00:48:16,000 --> 00:48:17,859
not be in contact with leader at all and

990
00:48:17,859 --> 00:48:19,690
you know the follower doesn't really

991
00:48:19,690 --> 00:48:20,980
have a way of knowing

992
00:48:20,980 --> 00:48:23,500
that actually it's just been cut off a

993
00:48:23,500 --> 00:48:25,720
moment ago from the leader and just not

994
00:48:25,720 --> 00:48:29,230
getting anything so you know without

995
00:48:29,230 --> 00:48:32,619
some further cleverness if we want to

996
00:48:32,619 --> 00:48:35,020
build a linearizable system we can't

997
00:48:35,020 --> 00:48:37,000
play this game of sending the attractive

998
00:48:37,000 --> 00:48:38,829
it as it is for performance we can't

999
00:48:38,829 --> 00:48:40,210
play this game at replicas sending a

1000
00:48:40,210 --> 00:48:43,570
read request to the replicas and you

1001
00:48:43,570 --> 00:48:44,920
shouldn't do it for lab 3 either because

1002
00:48:44,920 --> 00:48:47,020
that 3 is also supposed to be

1003
00:48:47,020 --> 00:48:53,440
linearizable it's any any questions

1004
00:48:53,440 --> 00:48:57,579
about why linearize ability forbids us

1005
00:48:57,579 --> 00:49:02,890
from having replicas serve clients ok

1006
00:49:02,890 --> 00:49:07,690
you know that the proof is the I lost it

1007
00:49:07,690 --> 00:49:11,250
now but the proof was that simple

1008
00:49:11,400 --> 00:49:13,990
reading you know right one right to read

1009
00:49:13,990 --> 00:49:16,980
one example I put on the board earlier

1010
00:49:16,980 --> 00:49:19,900
you not a lot just you know this is not

1011
00:49:19,900 --> 00:49:21,070
allowed to serve stale data in the

1012
00:49:21,070 --> 00:49:28,119
linear linearizable system ok so how

1013
00:49:28,119 --> 00:49:29,619
does how does zookeeper our deal with

1014
00:49:29,619 --> 00:49:31,180
this zookeeper actually does you can

1015
00:49:31,180 --> 00:49:33,040
tell from table two you look in Table

1016
00:49:33,040 --> 00:49:35,470
two zookeepers read performance goes up

1017
00:49:35,470 --> 00:49:38,020
dramatically as you add more servers so

1018
00:49:38,020 --> 00:49:39,790
clearly zookeepers playing some game

1019
00:49:39,790 --> 00:49:41,650
here which allows must be allowing it to

1020
00:49:41,650 --> 00:49:44,380
return read only to serve read only

1021
00:49:44,380 --> 00:49:46,869
requests from the additional servers the

1022
00:49:46,869 --> 00:49:50,050
replicas so how does zookeeper make

1023
00:49:50,050 --> 00:49:52,410
this safe

1024
00:49:59,010 --> 00:50:01,060
that's right I mean in fact it's almost

1025
00:50:01,060 --> 00:50:02,200
not allowed to say it does need the

1026
00:50:02,200 --> 00:50:05,110
written latest yeah the way zookeeper

1027
00:50:05,110 --> 00:50:06,580
skins this cat is that it's not

1028
00:50:06,580 --> 00:50:09,340
linearizable right they just like to

1029
00:50:09,340 --> 00:50:10,690
find away this problem and say well

1030
00:50:10,690 --> 00:50:12,220
we're not gonna be we're not going to

1031
00:50:12,220 --> 00:50:14,500
provide linearizable reads and so

1032
00:50:14,500 --> 00:50:17,470
therefore you don't are not obliged

1033
00:50:17,470 --> 00:50:20,230
you know zookeepers not obliged to

1034
00:50:20,230 --> 00:50:23,950
provide fresh data to reads it's allowed

1035
00:50:23,950 --> 00:50:25,690
by its rules of consistency which are

1036
00:50:25,690 --> 00:50:28,510
not linearizable to produce stale data

1037
00:50:28,510 --> 00:50:31,720
for Wheaton's so it's sort of solved

1038
00:50:31,720 --> 00:50:33,900
this technical problem with a kind of

1039
00:50:33,900 --> 00:50:37,300
definitional wave of the wand by saying

1040
00:50:37,300 --> 00:50:38,830
well we never owed you them linearizable

1041
00:50:38,830 --> 00:50:41,170
it'll be in the first place so it's not

1042
00:50:41,170 --> 00:50:45,760
a bug if you don't provide it and that's

1043
00:50:45,760 --> 00:50:46,870
actually a pretty classic way to

1044
00:50:46,870 --> 00:50:49,900
approach this to approach the sort of

1045
00:50:49,900 --> 00:50:53,620
tension between performance and strict

1046
00:50:53,620 --> 00:50:55,990
and strong consistency is to just not

1047
00:50:55,990 --> 00:50:58,180
provide strong consistency nevertheless

1048
00:50:58,180 --> 00:51:00,250
we have to keep in the back of our minds

1049
00:51:00,250 --> 00:51:03,760
question of if the system doesn't

1050
00:51:03,760 --> 00:51:07,300
provide linearize ability is it still

1051
00:51:07,300 --> 00:51:09,520
going to be useful right and you do a

1052
00:51:09,520 --> 00:51:11,380
read and you just don't get the current

1053
00:51:11,380 --> 00:51:12,700
answer or current correct answer the

1054
00:51:12,700 --> 00:51:14,590
most latest data like why do we believe

1055
00:51:14,590 --> 00:51:16,270
that that's gonna produce a useful

1056
00:51:16,270 --> 00:51:22,780
system and so let me talk about that so

1057
00:51:22,780 --> 00:51:26,440
first of all any questions about about

1058
00:51:26,440 --> 00:51:28,480
the basic problem zookeeper really does

1059
00:51:28,480 --> 00:51:30,460
allow client to send read-only requests

1060
00:51:30,460 --> 00:51:33,490
to any replica and the replica responds

1061
00:51:33,490 --> 00:51:35,380
out of its current state and that

1062
00:51:35,380 --> 00:51:37,210
replicate may be lagging it's log may

1063
00:51:37,210 --> 00:51:39,220
not have the very latest log entries and

1064
00:51:39,220 --> 00:51:42,520
so it may return stale data even though

1065
00:51:42,520 --> 00:51:46,200
there's a more recent committed value

1066
00:51:46,650 --> 00:51:51,780
okay so what are we left with

1067
00:51:51,780 --> 00:51:55,990
zookeeper does actually have some it

1068
00:51:55,990 --> 00:51:57,670
does have a set of consistency

1069
00:51:57,670 --> 00:52:01,180
guarantees so to help people who write

1070
00:52:01,180 --> 00:52:02,980
zookeeper based applications reason

1071
00:52:02,980 --> 00:52:04,540
about what their applications what's

1072
00:52:04,540 --> 00:52:05,650
actually going to happen when they run

1073
00:52:05,650 --> 00:52:07,770
them so

1074
00:52:07,770 --> 00:52:09,270
and these guarantees have to do with

1075
00:52:09,270 --> 00:52:10,980
ordering as indeed linearise ability

1076
00:52:10,980 --> 00:52:15,300
does so zookeeper does have two main

1077
00:52:15,300 --> 00:52:17,990
guarantees that they state and this is

1078
00:52:17,990 --> 00:52:22,400
section 2.3 one of them is it says that

1079
00:52:22,400 --> 00:52:33,839
rights rights or linearizable now you

1080
00:52:33,839 --> 00:52:34,980
know there are notion of linearizable

1081
00:52:34,980 --> 00:52:37,650
isn't not quite the same in mine maybe

1082
00:52:37,650 --> 00:52:40,440
because they're talking about rights no

1083
00:52:40,440 --> 00:52:43,589
beads what they really mean here is that

1084
00:52:43,589 --> 00:52:48,300
the system behaves as if even though

1085
00:52:48,300 --> 00:52:50,390
clients might submit rights concurrently

1086
00:52:50,390 --> 00:52:52,890
nevertheless the system behaves as if it

1087
00:52:52,890 --> 00:52:55,230
executes the rights one at a time in

1088
00:52:55,230 --> 00:52:59,490
some order and indeed obeys real-time

1089
00:52:59,490 --> 00:53:01,020
ordering of right so if one right has

1090
00:53:01,020 --> 00:53:03,270
seen to have completed before another

1091
00:53:03,270 --> 00:53:05,310
right has issued then do keeper will

1092
00:53:05,310 --> 00:53:07,320
indeed act as if it executed the second

1093
00:53:07,320 --> 00:53:09,990
right after the first right so it's

1094
00:53:09,990 --> 00:53:12,920
rights but not reads are linearizable

1095
00:53:12,920 --> 00:53:17,220
and zookeeper isn't a strict readwrite

1096
00:53:17,220 --> 00:53:20,089
system there are actually rights that

1097
00:53:20,089 --> 00:53:23,220
imply reads also and for those sort of

1098
00:53:23,220 --> 00:53:26,670
mixed rights those those you know any

1099
00:53:26,670 --> 00:53:29,490
any operation that modifies the state is

1100
00:53:29,490 --> 00:53:31,140
linearizable with respect to all other

1101
00:53:31,140 --> 00:53:37,320
operations that modify the state the

1102
00:53:37,320 --> 00:53:42,660
other guarantee of gives is that any

1103
00:53:42,660 --> 00:53:47,250
given client its operations executes in

1104
00:53:47,250 --> 00:53:49,560
the order specified by the client

1105
00:53:49,560 --> 00:53:54,800
they call that FIFO client order

1106
00:53:56,119 --> 00:53:58,110
and what this means is that if a

1107
00:53:58,110 --> 00:54:00,450
particular client issues a right and

1108
00:54:00,450 --> 00:54:02,220
then a read and then a read and a right

1109
00:54:02,220 --> 00:54:05,880
or whatever that first of all the rights

1110
00:54:05,880 --> 00:54:09,990
from that sequence fit in in the client

1111
00:54:09,990 --> 00:54:13,110
specified order in the overall order of

1112
00:54:13,110 --> 00:54:15,960
all clients rights so if a client says

1113
00:54:15,960 --> 00:54:18,150
do this right then that right and the

1114
00:54:18,150 --> 00:54:21,140
third right in the final order of rights

1115
00:54:21,140 --> 00:54:24,210
will see the clients rates occur in the

1116
00:54:24,210 --> 00:54:26,280
order of the client specified so for

1117
00:54:26,280 --> 00:54:32,340
rights this is our client specified

1118
00:54:32,340 --> 00:54:38,310
order and this is particularly you know

1119
00:54:38,310 --> 00:54:40,920
this is a issue with the system because

1120
00:54:40,920 --> 00:54:41,880
clients are allowed to launch

1121
00:54:41,880 --> 00:54:44,610
asynchronous right requests that is a

1122
00:54:44,610 --> 00:54:46,290
client can fire off a whole sequence of

1123
00:54:46,290 --> 00:54:49,140
rights to the leader to the zookeeper

1124
00:54:49,140 --> 00:54:51,060
leader without waiting for any of them

1125
00:54:51,060 --> 00:54:53,970
to complete and in order resume the

1126
00:54:53,970 --> 00:54:55,500
paper doesn't exactly say this but

1127
00:54:55,500 --> 00:54:57,480
presumably in order for the leader to

1128
00:54:57,480 --> 00:54:59,580
actually be able to execute the clients

1129
00:54:59,580 --> 00:55:00,930
rights in the client specified order

1130
00:55:00,930 --> 00:55:03,300
we're imagining I'm imagining that the

1131
00:55:03,300 --> 00:55:04,920
client actually stamps its write

1132
00:55:04,920 --> 00:55:07,680
requests with numbers and saying you

1133
00:55:07,680 --> 00:55:08,910
know I'll do this one first this one

1134
00:55:08,910 --> 00:55:11,670
second this one third and the zookeeper

1135
00:55:11,670 --> 00:55:14,310
leader obeys that ordering right so this

1136
00:55:14,310 --> 00:55:15,810
is particularly interesting due to these

1137
00:55:15,810 --> 00:55:19,170
asynchronous write requests and for

1138
00:55:19,170 --> 00:55:25,670
reads this is a little more complicated

1139
00:55:25,670 --> 00:55:27,990
the reasons I said before don't go

1140
00:55:27,990 --> 00:55:29,280
through the writes all go through the

1141
00:55:29,280 --> 00:55:31,470
leader the reads just go to some

1142
00:55:31,470 --> 00:55:33,359
replicas and so all they see is the

1143
00:55:33,359 --> 00:55:35,220
stuff that happens to have made it to

1144
00:55:35,220 --> 00:55:38,280
that replicas log the way we're supposed

1145
00:55:38,280 --> 00:55:41,520
to think about the FIFO client order for

1146
00:55:41,520 --> 00:55:43,650
reads is that if the client issues a

1147
00:55:43,650 --> 00:55:45,690
sequence of reads again in some order

1148
00:55:45,690 --> 00:55:47,340
the client reads one thing and then

1149
00:55:47,340 --> 00:55:48,359
another thing and then a third thing

1150
00:55:48,359 --> 00:55:53,490
that relative to the log on the replicas

1151
00:55:53,490 --> 00:55:59,130
talking to those clients reads each have

1152
00:55:59,130 --> 00:56:00,960
to occur at some particular point in the

1153
00:56:00,960 --> 00:56:05,220
log or they need to sort of observe the

1154
00:56:05,220 --> 00:56:07,740
state as it as the state existed at a

1155
00:56:07,740 --> 00:56:08,549
particular point

1156
00:56:08,549 --> 00:56:11,279
the log and furthermore that the

1157
00:56:11,279 --> 00:56:14,699
successive reads have to observe points

1158
00:56:14,699 --> 00:56:17,189
that don't go backwards that is if a

1159
00:56:17,189 --> 00:56:18,749
client issues one read and then another

1160
00:56:18,749 --> 00:56:20,369
read and the first read executes at this

1161
00:56:20,369 --> 00:56:21,929
point in the log the second read is that

1162
00:56:21,929 --> 00:56:24,779
you know allowed to execute it the same

1163
00:56:24,779 --> 00:56:26,519
or later points in the log but not

1164
00:56:26,519 --> 00:56:29,789
allowed to see a previous state by issue

1165
00:56:29,789 --> 00:56:30,959
one read and then another read the

1166
00:56:30,959 --> 00:56:32,819
second read has to see a state that's at

1167
00:56:32,819 --> 00:56:34,859
least as up-to-date as the first state

1168
00:56:34,859 --> 00:56:41,160
and that's a significant fact in that

1169
00:56:41,160 --> 00:56:43,019
we're gonna harness when we're reasoning

1170
00:56:43,019 --> 00:56:45,809
about how to write correct zookeeper

1171
00:56:45,809 --> 00:56:47,729
applications and where this is

1172
00:56:47,729 --> 00:56:50,489
especially exciting is that if the

1173
00:56:50,489 --> 00:56:52,109
client is talking to one replica for a

1174
00:56:52,109 --> 00:56:54,299
while and it issues some reads issue to

1175
00:56:54,299 --> 00:56:56,729
read here and then I read there if this

1176
00:56:56,729 --> 00:56:59,069
replica fails and the client needs to

1177
00:56:59,069 --> 00:57:00,269
start sending its read to another

1178
00:57:00,269 --> 00:57:03,900
replica that guaranteed this FIFO client

1179
00:57:03,900 --> 00:57:07,140
or a guarantee still holds if the client

1180
00:57:07,140 --> 00:57:08,999
switches to a new replica and so that

1181
00:57:08,999 --> 00:57:10,679
means that if you know before a crash

1182
00:57:10,679 --> 00:57:13,049
the client did a read that sort of saw

1183
00:57:13,049 --> 00:57:16,769
state as of this point in the log that

1184
00:57:16,769 --> 00:57:18,119
means when the clients wishes to the new

1185
00:57:18,119 --> 00:57:20,910
replicas if it issues another read you

1186
00:57:20,910 --> 00:57:22,709
know it's its previous read executed

1187
00:57:22,709 --> 00:57:23,189
here

1188
00:57:23,189 --> 00:57:25,559
if a client issues another read that

1189
00:57:25,559 --> 00:57:27,089
read has to execute at this point or

1190
00:57:27,089 --> 00:57:29,599
later even though it's switched replicas

1191
00:57:29,599 --> 00:57:32,519
and you know the way this works is that

1192
00:57:32,519 --> 00:57:35,789
each of these log entries is tagged by

1193
00:57:35,789 --> 00:57:39,719
the leader tags it with a Z X ID which

1194
00:57:39,719 --> 00:57:42,079
is basically just a entry number

1195
00:57:42,079 --> 00:57:45,390
whenever a replica responds to a client

1196
00:57:45,390 --> 00:57:47,849
read request it you know executed the

1197
00:57:47,849 --> 00:57:49,349
request at a particular point and the

1198
00:57:49,349 --> 00:57:52,979
replica responds with the Z X ID of the

1199
00:57:52,979 --> 00:57:54,599
immediately preceding log entry back to

1200
00:57:54,599 --> 00:57:57,239
the client the client remembers this was

1201
00:57:57,239 --> 00:58:00,420
the exid of the most recent data you

1202
00:58:00,420 --> 00:58:01,859
know is the highest z x idea i've ever

1203
00:58:01,859 --> 00:58:04,829
seen and when the client sends a request

1204
00:58:04,829 --> 00:58:07,499
to the same or a different replica it

1205
00:58:07,499 --> 00:58:09,779
accompanies their request with that

1206
00:58:09,779 --> 00:58:11,729
highest CX ID has ever seen and that

1207
00:58:11,729 --> 00:58:14,160
tells this other replica aha you know i

1208
00:58:14,160 --> 00:58:16,679
need to respond to that request with

1209
00:58:16,679 --> 00:58:19,679
data that's at least relative to this

1210
00:58:19,679 --> 00:58:21,190
point in a log

1211
00:58:21,190 --> 00:58:22,839
and that's interesting if this you know

1212
00:58:22,839 --> 00:58:25,089
this replicas not up this second replica

1213
00:58:25,089 --> 00:58:28,000
is even less up to date yes was then

1214
00:58:28,000 --> 00:58:29,920
received any of these but it receives a

1215
00:58:29,920 --> 00:58:31,270
request from a client the client says oh

1216
00:58:31,270 --> 00:58:34,630
gosh the last read I did executed this

1217
00:58:34,630 --> 00:58:36,339
spot in the log and some other replica

1218
00:58:36,339 --> 00:58:38,950
this replica needs to wait until it's

1219
00:58:38,950 --> 00:58:41,289
gotten the entire log up to this point

1220
00:58:41,289 --> 00:58:42,819
before it's allowed to respond to the

1221
00:58:42,819 --> 00:58:46,539
client and I'm not sure exactly how that

1222
00:58:46,539 --> 00:58:48,309
works but either the replicas just

1223
00:58:48,309 --> 00:58:51,069
delays responding to the read or maybe

1224
00:58:51,069 --> 00:58:52,510
it rejects the read and says look I just

1225
00:58:52,510 --> 00:58:53,770
don't know the information talk to

1226
00:58:53,770 --> 00:58:55,059
somebody else or talk to me later

1227
00:58:55,059 --> 00:58:57,280
where's eventually the you know this

1228
00:58:57,280 --> 00:58:59,289
replica will catch up if it's connected

1229
00:58:59,289 --> 00:59:01,210
to the leader and then you won't be able

1230
00:59:01,210 --> 00:59:03,630
to respond

1231
00:59:04,119 --> 00:59:06,730
okay so reads are ordered they only go

1232
00:59:06,730 --> 00:59:08,950
forward in time or only go forward in

1233
00:59:08,950 --> 00:59:12,670
sort of log order and a further thing

1234
00:59:12,670 --> 00:59:14,140
which I believe is true about reason

1235
00:59:14,140 --> 00:59:18,039
rights is that reads and writes the FIFO

1236
00:59:18,039 --> 00:59:20,380
client order applies to all of a clients

1237
00:59:20,380 --> 00:59:22,750
all of a single clients requests so if I

1238
00:59:22,750 --> 00:59:25,359
do a write from a client and I send a

1239
00:59:25,359 --> 00:59:28,210
write to the leader it takes time before

1240
00:59:28,210 --> 00:59:29,829
that write is sent out committed

1241
00:59:29,829 --> 00:59:31,359
whatever so I may send it right to the

1242
00:59:31,359 --> 00:59:33,099
leader the leader hasn't processed it or

1243
00:59:33,099 --> 00:59:36,660
committed it yet and then I send a read

1244
00:59:36,660 --> 00:59:39,789
to a replica the read may have to stall

1245
00:59:39,789 --> 00:59:41,740
you know in order to guarantee FIFO

1246
00:59:41,740 --> 00:59:43,779
client order the read and they have to

1247
00:59:43,779 --> 00:59:45,910
stall until this client has actually

1248
00:59:45,910 --> 00:59:48,730
seen and executed the previous the

1249
00:59:48,730 --> 00:59:52,029
client's previous write operation so

1250
00:59:52,029 --> 00:59:53,980
that's a consequence of this type of

1251
00:59:53,980 --> 00:59:55,930
client order is that a reason rights are

1252
00:59:55,930 --> 00:59:58,119
in the same order and you know the way

1253
00:59:58,119 --> 01:00:00,760
the most obvious way to see this is if a

1254
01:00:00,760 --> 01:00:03,400
client writes a particular piece of data

1255
01:00:03,400 --> 01:00:05,650
you know sends a write to the leader and

1256
01:00:05,650 --> 01:00:07,690
then immediately does a read of the same

1257
01:00:07,690 --> 01:00:09,430
piece of data and sends that read to a

1258
01:00:09,430 --> 01:00:11,680
replica boy it better see its own

1259
01:00:11,680 --> 01:00:13,450
written value right if I write something

1260
01:00:13,450 --> 01:00:16,359
to have value 17 and then I do a read

1261
01:00:16,359 --> 01:00:18,970
and it doesn't have value 17 then that's

1262
01:00:18,970 --> 01:00:21,670
just bizarre and it's evidence that gosh

1263
01:00:21,670 --> 01:00:23,740
the system was not executing my requests

1264
01:00:23,740 --> 01:00:25,299
in order because then it would have

1265
01:00:25,299 --> 01:00:27,220
executed the write and then before the

1266
01:00:27,220 --> 01:00:29,319
read so there must be some funny

1267
01:00:29,319 --> 01:00:31,450
business with the replicas stalling

1268
01:00:31,450 --> 01:00:33,670
the client must when it sends a read and

1269
01:00:33,670 --> 01:00:35,559
say look you know I the last write

1270
01:00:35,559 --> 01:00:37,269
request I sent a leader with ZX ID

1271
01:00:37,269 --> 01:00:39,730
something in this replica has to wait

1272
01:00:39,730 --> 01:00:44,640
till it sees that I'm the leader yes

1273
01:00:53,660 --> 01:00:56,390
oh absolutely so I think what you're

1274
01:00:56,390 --> 01:00:58,250
observing is that a read from a replica

1275
01:00:58,250 --> 01:01:00,880
may not see the latest data so the

1276
01:01:00,880 --> 01:01:03,650
leader may have sent out C to a majority

1277
01:01:03,650 --> 01:01:06,890
of replicas and committed it and the

1278
01:01:06,890 --> 01:01:08,930
majority may have executed it but if our

1279
01:01:08,930 --> 01:01:10,640
replica that we're talking wasn't in

1280
01:01:10,640 --> 01:01:12,710
that majority maybe this replica doesn't

1281
01:01:12,710 --> 01:01:14,119
have the latest data and that just is

1282
01:01:14,119 --> 01:01:17,900
the way zoo keeper works and so it does

1283
01:01:17,900 --> 01:01:20,329
not guarantee that we'd see the latest

1284
01:01:20,329 --> 01:01:23,900
data so if there there is a guarantee

1285
01:01:23,900 --> 01:01:25,339
about readwrite ordering but it's only

1286
01:01:25,339 --> 01:01:28,849
per client so if I send a write in and

1287
01:01:28,849 --> 01:01:31,880
then I read that data the system

1288
01:01:31,880 --> 01:01:34,069
guarantees that my bead observes my

1289
01:01:34,069 --> 01:01:37,039
right if you send a right in and then I

1290
01:01:37,039 --> 01:01:39,920
read the data that you wrote this isn't

1291
01:01:39,920 --> 01:01:43,029
does not guarantee that I see your right

1292
01:01:43,029 --> 01:01:46,069
and that's and you know that's like the

1293
01:01:46,069 --> 01:01:50,119
foundation of how they get speed up for

1294
01:01:50,119 --> 01:01:51,470
reads proportional to the number of

1295
01:01:51,470 --> 01:01:53,890
replicas

1296
01:01:58,560 --> 01:02:00,900
but I would say the system isn't

1297
01:02:00,900 --> 01:02:04,560
linearizable and and but it is not that

1298
01:02:04,560 --> 01:02:07,080
it has no properties then the rights are

1299
01:02:07,080 --> 01:02:09,120
certainly many all right all rights from

1300
01:02:09,120 --> 01:02:11,790
all clients form some one at a time

1301
01:02:11,790 --> 01:02:13,950
sequence so that's a sense in which the

1302
01:02:13,950 --> 01:02:16,170
rights all rights are the knee risible

1303
01:02:16,170 --> 01:02:21,260
and each individual clients operations

1304
01:02:21,260 --> 01:02:27,000
may be this means linearizable also it

1305
01:02:27,000 --> 01:02:29,340
may you know this this probably means

1306
01:02:29,340 --> 01:02:31,050
that each individual clients operations

1307
01:02:31,050 --> 01:02:32,280
are linearize well though I'm not quite

1308
01:02:32,280 --> 01:02:48,810
sure you know I'm actually not sure how

1309
01:02:48,810 --> 01:02:50,820
it works but that's a reasonable

1310
01:02:50,820 --> 01:02:52,200
supposition then when I send in an

1311
01:02:52,200 --> 01:02:54,660
asynchronous right the system doesn't

1312
01:02:54,660 --> 01:02:56,190
execute it yet but it does reply to me

1313
01:02:56,190 --> 01:02:57,270
saying yeah you know I got your right

1314
01:02:57,270 --> 01:02:59,070
and here's this yaks ID that it will

1315
01:02:59,070 --> 01:03:03,090
have if it's committed I just like start

1316
01:03:03,090 --> 01:03:04,920
return so that's a reasonable theory I

1317
01:03:04,920 --> 01:03:06,360
don't actually know how it does it and

1318
01:03:06,360 --> 01:03:11,040
then the client if it doesn't read needs

1319
01:03:11,040 --> 01:03:12,330
to tell the replicas look you know

1320
01:03:12,330 --> 01:03:31,830
that's right I did you know if I do a

1321
01:03:31,830 --> 01:03:42,030
read of the data is of the operation

1322
01:03:42,030 --> 01:03:43,740
okay so if you send a read to a replica

1323
01:03:43,740 --> 01:03:45,600
the replicas in return you that you know

1324
01:03:45,600 --> 01:03:47,310
really it's a read from this table is

1325
01:03:47,310 --> 01:03:49,590
what your no way notionally what the

1326
01:03:49,590 --> 01:03:51,240
client thinks it's doing so you client

1327
01:03:51,240 --> 01:03:52,290
says all I want to read this row from

1328
01:03:52,290 --> 01:03:54,390
this table the server this replica sends

1329
01:03:54,390 --> 01:03:56,310
back its current value for that table

1330
01:03:56,310 --> 01:04:00,270
plus the GX ID of the last operation

1331
01:04:00,270 --> 01:04:03,500
that updated that table

1332
01:04:06,570 --> 01:04:10,110
yeah so there's so actually I'm I'm not

1333
01:04:10,110 --> 01:04:13,560
prepared to so the the two things that

1334
01:04:13,560 --> 01:04:14,910
would make sense and I think either of

1335
01:04:14,910 --> 01:04:17,340
them would be okay is the server could

1336
01:04:17,340 --> 01:04:20,310
track this yet for every table row the

1337
01:04:20,310 --> 01:04:22,380
ZX ID of the last right operation that

1338
01:04:22,380 --> 01:04:25,140
touched it or it could just to all read

1339
01:04:25,140 --> 01:04:27,870
requests returned the ZX ID as a last

1340
01:04:27,870 --> 01:04:29,100
committed operation in its log

1341
01:04:29,100 --> 01:04:31,590
regardless of whether that was the last

1342
01:04:31,590 --> 01:04:34,110
operation of touch that row because all

1343
01:04:34,110 --> 01:04:36,000
we need to do is make sure that client

1344
01:04:36,000 --> 01:04:38,700
requests move forward in the order so we

1345
01:04:38,700 --> 01:04:40,170
just need something to return something

1346
01:04:40,170 --> 01:04:42,540
that's greater than or equal to the

1347
01:04:42,540 --> 01:04:45,720
right that last touched the data that

1348
01:04:45,720 --> 01:04:54,570
the client read all right so these are

1349
01:04:54,570 --> 01:05:01,440
the guarantees so you know we still left

1350
01:05:01,440 --> 01:05:02,370
with a question of whether it's possible

1351
01:05:02,370 --> 01:05:04,980
to do reasonable programming with this

1352
01:05:04,980 --> 01:05:06,780
set of guarantees and the answer is well

1353
01:05:06,780 --> 01:05:08,400
this you know at a high level this is

1354
01:05:08,400 --> 01:05:11,040
not quite as good as linearizable it's a

1355
01:05:11,040 --> 01:05:12,330
little bit harder to reason about and

1356
01:05:12,330 --> 01:05:14,010
there's sort of more gotchas like reads

1357
01:05:14,010 --> 01:05:15,690
can return stale data just can't happen

1358
01:05:15,690 --> 01:05:18,510
in a linearizable system but it's

1359
01:05:18,510 --> 01:05:21,090
nevertheless good enough to do to make

1360
01:05:21,090 --> 01:05:22,800
it pretty straightforward to reason

1361
01:05:22,800 --> 01:05:27,900
about a lot of things you might want to

1362
01:05:27,900 --> 01:05:33,990
do with zookeeper so there's a so I'm

1363
01:05:33,990 --> 01:05:35,520
gonna try to construct an argument maybe

1364
01:05:35,520 --> 01:05:38,040
by example of why this is not such a bad

1365
01:05:38,040 --> 01:05:41,130
programming model one reason by the way

1366
01:05:41,130 --> 01:05:42,630
is that there's an out there's this

1367
01:05:42,630 --> 01:05:44,160
operation called sync which is

1368
01:05:44,160 --> 01:05:47,010
essentially a write operation and if a

1369
01:05:47,010 --> 01:05:49,410
client you know supposing I know that

1370
01:05:49,410 --> 01:05:51,660
you recently wrote something you being a

1371
01:05:51,660 --> 01:05:53,100
different client and I want to read what

1372
01:05:53,100 --> 01:05:54,660
you wrote so I actually want fresh data

1373
01:05:54,660 --> 01:05:57,780
I can send in one of these sync

1374
01:05:57,780 --> 01:06:03,180
operations which is effectively well the

1375
01:06:03,180 --> 01:06:04,560
sync operation makes its way through the

1376
01:06:04,560 --> 01:06:07,890
system as if it were a write and you

1377
01:06:07,890 --> 01:06:09,930
know finally showing up in the logs of

1378
01:06:09,930 --> 01:06:12,690
the replicas that really at least the

1379
01:06:12,690 --> 01:06:14,670
replicas that I'm talking to and then I

1380
01:06:14,670 --> 01:06:18,160
can come back and do a read and you know

1381
01:06:18,160 --> 01:06:20,920
I can I can tell the replica basically

1382
01:06:20,920 --> 01:06:23,079
don't serve this read until you've seen

1383
01:06:23,079 --> 01:06:26,079
my last sync and that actually falls out

1384
01:06:26,079 --> 01:06:29,190
naturally from fifl client order if we

1385
01:06:29,190 --> 01:06:33,039
if we countersink as a right then five-o

1386
01:06:33,039 --> 01:06:34,750
client order says reads are required to

1387
01:06:34,750 --> 01:06:37,509
see state you know there's as least as

1388
01:06:37,509 --> 01:06:39,130
up to date is the last right from that

1389
01:06:39,130 --> 01:06:41,410
client and so if I send in a sync and

1390
01:06:41,410 --> 01:06:45,160
then I do read I'm the the system is

1391
01:06:45,160 --> 01:06:47,410
obliged to give me data that's visas up

1392
01:06:47,410 --> 01:06:49,960
to date as where my sync fell in the log

1393
01:06:49,960 --> 01:06:52,269
order anyway if I need to read

1394
01:06:52,269 --> 01:06:54,759
up-to-date data send in a sync then do a

1395
01:06:54,759 --> 01:06:57,630
read and the read is guaranteed to see

1396
01:06:57,630 --> 01:07:01,420
data as of the time the same was entered

1397
01:07:01,420 --> 01:07:05,140
into the log so reasonably fresh so

1398
01:07:05,140 --> 01:07:06,730
that's one out but it's an expensive one

1399
01:07:06,730 --> 01:07:08,559
because you now we converted a cheap

1400
01:07:08,559 --> 01:07:11,500
read into the sync operation which

1401
01:07:11,500 --> 01:07:14,109
burned up time on the leader so it's a

1402
01:07:14,109 --> 01:07:17,859
no-no if you don't have to do but here's

1403
01:07:17,859 --> 01:07:19,450
a couple of examples of scenarios that

1404
01:07:19,450 --> 01:07:23,349
the paper talks about that the reasoning

1405
01:07:23,349 --> 01:07:25,660
about them is simplified or reasonably

1406
01:07:25,660 --> 01:07:27,759
simple given the rules that are here so

1407
01:07:27,759 --> 01:07:29,349
first I want to talk about the trick in

1408
01:07:29,349 --> 01:07:32,619
section 2.3 of with the ready file where

1409
01:07:32,619 --> 01:07:34,809
we assume there's some master and the

1410
01:07:34,809 --> 01:07:36,869
Masters maintaining a configuration in

1411
01:07:36,869 --> 01:07:39,190
zookeeper which is a bunch of files and

1412
01:07:39,190 --> 01:07:41,019
zookeeper that describe you know

1413
01:07:41,019 --> 01:07:43,150
something about our distributed system

1414
01:07:43,150 --> 01:07:45,190
like the IP addresses of all the workers

1415
01:07:45,190 --> 01:07:48,910
or who the master is or something so we

1416
01:07:48,910 --> 01:07:51,190
the master who's updating this

1417
01:07:51,190 --> 01:07:52,630
configuration and maybe a bunch of

1418
01:07:52,630 --> 01:07:54,130
readers that need to read the current

1419
01:07:54,130 --> 01:07:55,960
configuration and need to see it every

1420
01:07:55,960 --> 01:07:57,819
time it changes and so the question is

1421
01:07:57,819 --> 01:07:59,529
you know can we construct something that

1422
01:07:59,529 --> 01:08:02,349
even though updating the configure even

1423
01:08:02,349 --> 01:08:03,460
though the configuration is split across

1424
01:08:03,460 --> 01:08:05,920
many files in zookeeper we can have the

1425
01:08:05,920 --> 01:08:09,460
effect of an atomic update so that

1426
01:08:09,460 --> 01:08:11,740
workers don't see workers that look at

1427
01:08:11,740 --> 01:08:13,119
the configuration don't see a sort of

1428
01:08:13,119 --> 01:08:15,839
partially updated configuration but only

1429
01:08:15,839 --> 01:08:19,839
a completely updated that's a classic

1430
01:08:19,839 --> 01:08:23,469
kind of thing that this configuration

1431
01:08:23,469 --> 01:08:25,920
management that zookeeper people using

1432
01:08:25,920 --> 01:08:29,770
zookeeper for so you know looking at the

1433
01:08:29,770 --> 01:08:31,929
so we're copying what section 2.3

1434
01:08:31,929 --> 01:08:34,810
describes this will say the master is

1435
01:08:34,810 --> 01:08:36,460
doing a bunch of rites to update the

1436
01:08:36,460 --> 01:08:38,880
configuration and here's the order that

1437
01:08:38,880 --> 01:08:41,469
the master for our distributed system

1438
01:08:41,469 --> 01:08:43,080
does the rites

1439
01:08:43,080 --> 01:08:44,948
first we're assuming there's some ready

1440
01:08:44,948 --> 01:08:47,679
file a file named ready and if they're

1441
01:08:47,679 --> 01:08:49,390
ready file exists then the configuration

1442
01:08:49,390 --> 01:08:50,679
is we're allowed to read the

1443
01:08:50,679 --> 01:08:52,270
configuration if they're ready files

1444
01:08:52,270 --> 01:08:53,890
missing that means the configuration is

1445
01:08:53,890 --> 01:08:55,270
being updated and we shouldn't look at

1446
01:08:55,270 --> 01:08:58,000
it so if the master is gonna update the

1447
01:08:58,000 --> 01:08:59,350
configuration file the very first thing

1448
01:08:59,350 --> 01:09:07,238
it does is delete the ready file then it

1449
01:09:07,238 --> 01:09:10,569
writes the various files very zookeeper

1450
01:09:10,569 --> 01:09:13,839
files that hold the data for the

1451
01:09:13,839 --> 01:09:15,520
configuration might be a lot of files

1452
01:09:15,520 --> 01:09:17,859
nose and then when it's completely

1453
01:09:17,859 --> 01:09:19,540
updated all the files that make up the

1454
01:09:19,540 --> 01:09:24,149
configuration then it creates again

1455
01:09:24,149 --> 01:09:27,539
that's ready file

1456
01:09:28,380 --> 01:09:31,960
alright so so far the semantics are

1457
01:09:31,960 --> 01:09:33,670
extremely straightforward this is just

1458
01:09:33,670 --> 01:09:35,140
rights there's only rights here no reads

1459
01:09:35,140 --> 01:09:37,000
rights are guaranteed to execute in

1460
01:09:37,000 --> 01:09:42,520
linear order and I guess now we have to

1461
01:09:42,520 --> 01:09:44,408
appeal the fifl client order if the

1462
01:09:44,408 --> 01:09:46,630
master sort of tags these as oh you know

1463
01:09:46,630 --> 01:09:48,399
I want my rights to occur in this order

1464
01:09:48,399 --> 01:09:52,270
then the reader is obliged to enter them

1465
01:09:52,270 --> 01:09:53,859
into the replicated log in that order

1466
01:09:53,859 --> 01:09:56,080
and so though you know the replicas were

1467
01:09:56,080 --> 01:09:57,520
all dutifully execute these one at a

1468
01:09:57,520 --> 01:09:58,960
time they'll all delete the ready file

1469
01:09:58,960 --> 01:10:01,480
then apply this right in that right and

1470
01:10:01,480 --> 01:10:03,429
then create the ready file again so

1471
01:10:03,429 --> 01:10:05,590
these are rights the orders

1472
01:10:05,590 --> 01:10:08,770
straightforward for the reads though

1473
01:10:08,770 --> 01:10:13,420
it's it's maybe a little bit maybe a

1474
01:10:13,420 --> 01:10:14,409
little more thinking as required

1475
01:10:14,409 --> 01:10:16,150
supposing we have some worker that needs

1476
01:10:16,150 --> 01:10:21,909
to read the current configuration we're

1477
01:10:21,909 --> 01:10:25,239
going to assume that this worker first

1478
01:10:25,239 --> 01:10:28,870
checks to see whether the ready file

1479
01:10:28,870 --> 01:10:31,750
exists it doesn't exist it's gonna you

1480
01:10:31,750 --> 01:10:33,550
know sleep and try again so let's assume

1481
01:10:33,550 --> 01:10:35,679
it does exist let's assume we assume

1482
01:10:35,679 --> 01:10:41,199
that the worker checks to see

1483
01:10:41,199 --> 01:10:44,060
if the ready file exists after it's

1484
01:10:44,060 --> 01:10:46,640
recreated and so you know what this

1485
01:10:46,640 --> 01:10:48,050
means now these are all right requests

1486
01:10:48,050 --> 01:10:49,429
sent to the leader this is a read

1487
01:10:49,429 --> 01:10:52,850
request that's just centrally whatever

1488
01:10:52,850 --> 01:10:56,840
replica the clients talking to and then

1489
01:10:56,840 --> 01:11:00,290
if it exists you know it's gonna read f1

1490
01:11:00,290 --> 01:11:07,640
and B that - the interesting thing that

1491
01:11:07,640 --> 01:11:10,429
FIFO client order guarantees here is

1492
01:11:10,429 --> 01:11:17,600
that if this returned true that is if

1493
01:11:17,600 --> 01:11:18,860
the replica the client was talking to

1494
01:11:18,860 --> 01:11:21,140
said yes that file exists then you know

1495
01:11:21,140 --> 01:11:24,760
as were as that what that means is that

1496
01:11:24,760 --> 01:11:27,679
at least with this setup is that as that

1497
01:11:27,679 --> 01:11:32,120
replica that that replica had actually

1498
01:11:32,120 --> 01:11:33,880
seen the recreate of the ready file

1499
01:11:33,880 --> 01:11:38,179
right in order for this exist to see to

1500
01:11:38,179 --> 01:11:41,290
see the ready file exists and because

1501
01:11:41,290 --> 01:11:44,270
successive read operations are required

1502
01:11:44,270 --> 01:11:47,449
to march along only forwards in the long

1503
01:11:47,449 --> 01:11:49,790
and never backwards that means that you

1504
01:11:49,790 --> 01:11:52,190
know if the replicas the client was

1505
01:11:52,190 --> 01:11:54,739
talking to if it's log actually

1506
01:11:54,739 --> 01:11:56,449
contained and then it executes this

1507
01:11:56,449 --> 01:11:58,370
creative the ready file that means that

1508
01:11:58,370 --> 01:12:02,060
subsequent client reads must move only

1509
01:12:02,060 --> 01:12:07,340
forward in the sequence of rights you

1510
01:12:07,340 --> 01:12:09,199
know that the leader put into the log so

1511
01:12:09,199 --> 01:12:11,570
if we saw this ready that means that the

1512
01:12:11,570 --> 01:12:13,610
read occurs that the replica excuse to

1513
01:12:13,610 --> 01:12:16,159
read down here somewhere after the right

1514
01:12:16,159 --> 01:12:18,140
that created the ready and that means

1515
01:12:18,140 --> 01:12:19,699
that the reads are guaranteed to observe

1516
01:12:19,699 --> 01:12:22,340
the effects of these rights so we do

1517
01:12:22,340 --> 01:12:24,170
actually get some benefit here some

1518
01:12:24,170 --> 01:12:25,690
reasoning benefit from the fact that

1519
01:12:25,690 --> 01:12:28,159
even though it's not fully linearizable

1520
01:12:28,159 --> 01:12:30,710
the rights are linearizable and the

1521
01:12:30,710 --> 01:12:32,719
reads have to read sort of monotonically

1522
01:12:32,719 --> 01:12:37,840
move forward in time to the log yes

1523
01:12:38,120 --> 01:12:41,279
[Music]

1524
01:12:49,400 --> 01:12:52,110
yeah so that's a great question so your

1525
01:12:52,110 --> 01:12:54,750
question is well in all this client

1526
01:12:54,750 --> 01:12:56,670
knows you know if this is the real

1527
01:12:56,670 --> 01:12:58,470
scenario that the creators entered in

1528
01:12:58,470 --> 01:13:01,800
the log and then the read arrives at the

1529
01:13:01,800 --> 01:13:03,510
replica after that replica executed this

1530
01:13:03,510 --> 01:13:04,560
creepy ready then everything's

1531
01:13:04,560 --> 01:13:06,030
straightforward but there's other

1532
01:13:06,030 --> 01:13:07,530
possibilities for how this stuff was

1533
01:13:07,530 --> 01:13:08,070
interleaved

1534
01:13:08,070 --> 01:13:11,660
so let's look at a much more troubling

1535
01:13:11,660 --> 01:13:21,570
scenario so the scenario you brought up

1536
01:13:21,570 --> 01:13:24,750
which I happen to be prepared to talk

1537
01:13:24,750 --> 01:13:28,530
about is that yeah you know the the

1538
01:13:28,530 --> 01:13:31,800
master at some point executed to a

1539
01:13:31,800 --> 01:13:36,840
delete of ready or you know way back in

1540
01:13:36,840 --> 01:13:40,710
time some previous master this master

1541
01:13:40,710 --> 01:13:41,990
created the ready file

1542
01:13:41,990 --> 01:13:44,790
you know after it finished updating the

1543
01:13:44,790 --> 01:13:46,680
state I say ready for I existed for a

1544
01:13:46,680 --> 01:13:48,030
while then some new master or this

1545
01:13:48,030 --> 01:13:48,870
master needs to change the

1546
01:13:48,870 --> 01:13:50,280
configurations release the ready file

1547
01:13:50,280 --> 01:13:56,270
you know it doesn't right right and

1548
01:13:56,270 --> 01:13:58,560
what's really troubling is that the

1549
01:13:58,560 --> 01:14:00,630
client that needs to read this

1550
01:14:00,630 --> 01:14:02,990
configuration might have called exists

1551
01:14:02,990 --> 01:14:06,630
to see whether the ready file exists at

1552
01:14:06,630 --> 01:14:12,750
this time all right and you know at this

1553
01:14:12,750 --> 01:14:14,100
point in time yeah sure the ready file

1554
01:14:14,100 --> 01:14:16,410
exists then time passes and the client

1555
01:14:16,410 --> 01:14:18,900
issues the reads for the maybe the

1556
01:14:18,900 --> 01:14:22,200
client reads the first file that makes

1557
01:14:22,200 --> 01:14:25,500
up the configuration but maybe it you

1558
01:14:25,500 --> 01:14:26,580
know and then it reads the second file

1559
01:14:26,580 --> 01:14:29,610
maybe this file this read comes totally

1560
01:14:29,610 --> 01:14:32,690
after the master has been changing the

1561
01:14:32,690 --> 01:14:35,220
configurations so now this reader has

1562
01:14:35,220 --> 01:14:38,880
read this damaged mix of f1 from the old

1563
01:14:38,880 --> 01:14:40,800
configuration and f2 from the new

1564
01:14:40,800 --> 01:14:42,030
configuration there's no reason to

1565
01:14:42,030 --> 01:14:44,210
believe that that's going to contain

1566
01:14:44,210 --> 01:14:46,350
anything other than broken information

1567
01:14:46,350 --> 01:14:49,320
so so this first scenario was great the

1568
01:14:49,320 --> 01:14:52,830
scenario is a disaster and so now we're

1569
01:14:52,830 --> 01:14:54,379
starting to get into

1570
01:14:54,379 --> 01:14:57,979
of like serious challenges which a

1571
01:14:57,979 --> 01:15:01,869
carefully designed API for coordination

1572
01:15:01,869 --> 01:15:05,030
between machines in a distributed system

1573
01:15:05,030 --> 01:15:07,669
might actually help us solve right

1574
01:15:07,669 --> 01:15:09,709
because like for lab 3 you know you're

1575
01:15:09,709 --> 01:15:11,599
gonna build a put get system and a

1576
01:15:11,599 --> 01:15:13,899
simple lab 3 style put guessed system

1577
01:15:13,899 --> 01:15:15,739
you know it would run into this problem

1578
01:15:15,739 --> 01:15:17,689
too and just does not have any tools to

1579
01:15:17,689 --> 01:15:18,320
deal with it

1580
01:15:18,320 --> 01:15:21,859
but the zookeeper API actually is more

1581
01:15:21,859 --> 01:15:23,929
clever than this and it can cope with it

1582
01:15:23,929 --> 01:15:27,979
and so what actually happens the way you

1583
01:15:27,979 --> 01:15:29,780
would actually use zookeeper is that

1584
01:15:29,780 --> 01:15:32,599
when the client sent in this exists

1585
01:15:32,599 --> 01:15:35,719
request to ask does this file exist and

1586
01:15:35,719 --> 01:15:37,249
would say not only does this file exist

1587
01:15:37,249 --> 01:15:41,570
but it would say you know tell me if it

1588
01:15:41,570 --> 01:15:44,030
exists even set a watch on that file

1589
01:15:44,030 --> 01:15:47,179
which means if the files ever deleted or

1590
01:15:47,179 --> 01:15:48,889
if it doesn't exist if it's ever created

1591
01:15:48,889 --> 01:15:51,439
but in this case if it if it is ever

1592
01:15:51,439 --> 01:15:55,599
deleted please send me a notification

1593
01:15:56,499 --> 01:16:01,760
and furthermore the notifications that

1594
01:16:01,760 --> 01:16:04,579
zookeeper sends you know it's a the

1595
01:16:04,579 --> 01:16:05,959
reader here it's only talking to some

1596
01:16:05,959 --> 01:16:08,209
replicas this is all the replicas doing

1597
01:16:08,209 --> 01:16:09,729
these things for it the replica

1598
01:16:09,729 --> 01:16:13,849
guarantees to send a notification for

1599
01:16:13,849 --> 01:16:16,669
some change to this ready file at the

1600
01:16:16,669 --> 01:16:20,439
correct point relative to the responses

1601
01:16:20,439 --> 01:16:25,639
to the clients reads and so what that

1602
01:16:25,639 --> 01:16:32,389
means so you know because that the the

1603
01:16:32,389 --> 01:16:34,519
implication of that is that in this

1604
01:16:34,519 --> 01:16:38,449
scenario in which you know these these

1605
01:16:38,449 --> 01:16:40,780
rights sort of fit in here in real time

1606
01:16:40,780 --> 01:16:44,030
the guarantee is that if you ask for a

1607
01:16:44,030 --> 01:16:45,679
watch on something and then you issue

1608
01:16:45,679 --> 01:16:49,369
some reads if that replica you're

1609
01:16:49,369 --> 01:16:51,379
talking to execute something that should

1610
01:16:51,379 --> 01:16:53,629
trigger the watch in during your

1611
01:16:53,629 --> 01:16:57,679
sequence of reads then the replica

1612
01:16:57,679 --> 01:16:59,449
guarantees to deliver the notification

1613
01:16:59,449 --> 01:17:02,090
about the watch before it responds to

1614
01:17:02,090 --> 01:17:05,300
any read that came that you know saw the

1615
01:17:05,300 --> 01:17:07,840
log after the point

1616
01:17:07,840 --> 01:17:10,540
of the OP where the operation that

1617
01:17:10,540 --> 01:17:12,850
triggered the watch notification

1618
01:17:12,850 --> 01:17:15,320
executed and so this is the log on the

1619
01:17:15,320 --> 01:17:18,950
replica and so you know if the so that

1620
01:17:18,950 --> 01:17:21,650
you know the FIFO client ordering will

1621
01:17:21,650 --> 01:17:23,600
say you know each client requests must

1622
01:17:23,600 --> 01:17:25,280
fit somewhere into the log apparently

1623
01:17:25,280 --> 01:17:27,800
these fit in here in the log what we're

1624
01:17:27,800 --> 01:17:29,930
worried about is that this read occurs

1625
01:17:29,930 --> 01:17:32,090
here in the log but we set up this watch

1626
01:17:32,090 --> 01:17:34,400
and the guarantee is that will receive

1627
01:17:34,400 --> 01:17:36,500
the note if if somebody deletes this

1628
01:17:36,500 --> 01:17:39,200
file and we can notified then that

1629
01:17:39,200 --> 01:17:40,940
notification will will appear at the

1630
01:17:40,940 --> 01:17:43,610
client before a read that yields

1631
01:17:43,610 --> 01:17:48,470
anything subsequently in the log will

1632
01:17:48,470 --> 01:17:49,940
get the notification before we get the

1633
01:17:49,940 --> 01:17:52,370
results of any read that's that saw

1634
01:17:52,370 --> 01:17:54,890
something in log after the operation

1635
01:17:54,890 --> 01:17:57,080
that produced the notification so what

1636
01:17:57,080 --> 01:17:58,820
this means that the delete ready is

1637
01:17:58,820 --> 01:18:00,650
gonna since we have a watch on the ready

1638
01:18:00,650 --> 01:18:02,330
file that elite ready is going to

1639
01:18:02,330 --> 01:18:05,420
generate a notification and that

1640
01:18:05,420 --> 01:18:07,130
notification is guaranteed to be

1641
01:18:07,130 --> 01:18:10,000
delivered before the read result of f2

1642
01:18:10,000 --> 01:18:13,340
if f2 was gonna see this second right

1643
01:18:13,340 --> 01:18:15,380
and that means that before the reading

1644
01:18:15,380 --> 01:18:17,510
client has finished the sequence in

1645
01:18:17,510 --> 01:18:19,220
which it looks at the configuration it's

1646
01:18:19,220 --> 01:18:23,230
guaranteed to see the watch notification

1647
01:18:23,230 --> 01:18:26,900
before it sees the results of any write

1648
01:18:26,900 --> 01:18:29,840
that happened after this delete that

1649
01:18:29,840 --> 01:18:32,770
triggered the notification

1650
01:18:39,320 --> 01:18:42,510
who generates the watch as well the

1651
01:18:42,510 --> 01:18:43,770
replica let's say the client is talking

1652
01:18:43,770 --> 01:18:45,659
to this replica and it sends in the

1653
01:18:45,659 --> 01:18:48,150
exists request the exist room has a read

1654
01:18:48,150 --> 01:18:49,679
only request it sends with his replica

1655
01:18:49,679 --> 01:18:51,659
the replica is being painting on the

1656
01:18:51,659 --> 01:18:54,000
side a table of watches saying oh you

1657
01:18:54,000 --> 01:18:55,440
know such-and-such a client asked for a

1658
01:18:55,440 --> 01:18:59,429
watch on this file and furthermore the

1659
01:18:59,429 --> 01:19:01,590
watch was established at a particular Z

1660
01:19:01,590 --> 01:19:03,840
X ID that is did a read that client did

1661
01:19:03,840 --> 01:19:05,969
a read with the replica executed the

1662
01:19:05,969 --> 01:19:07,920
read at this point in the log and return

1663
01:19:07,920 --> 01:19:09,630
results are relative to this point in

1664
01:19:09,630 --> 01:19:12,540
the log members owe that watch is

1665
01:19:12,540 --> 01:19:14,070
relative to that point in the log and

1666
01:19:14,070 --> 01:19:17,400
then if a delete comes in you know for

1667
01:19:17,400 --> 01:19:20,280
every operation that there s Q so it

1668
01:19:20,280 --> 01:19:21,540
looks in this little table it says aha

1669
01:19:21,540 --> 01:19:24,540
you know the a there was a watch on that

1670
01:19:24,540 --> 01:19:27,000
file and maybe it's indexed by hash of

1671
01:19:27,000 --> 01:19:29,810
filename or something

1672
01:19:37,440 --> 01:19:39,820
okay so the question is oh yeah this

1673
01:19:39,820 --> 01:19:41,889
this replica has to have a watch table

1674
01:19:41,889 --> 01:19:46,060
you know if the replica crashes and the

1675
01:19:46,060 --> 01:19:48,579
client is officially different replica

1676
01:19:48,579 --> 01:19:50,170
you know what about the watch table

1677
01:19:50,170 --> 01:19:51,159
right it's already established these

1678
01:19:51,159 --> 01:19:52,780
watch and the answer to that is that no

1679
01:19:52,780 --> 01:19:56,739
the rep your replica crashes the new

1680
01:19:56,739 --> 01:19:58,570
replica you switch to won't have the

1681
01:19:58,570 --> 01:20:01,360
watch table and but the client gets a

1682
01:20:01,360 --> 01:20:03,610
notification at the appropriate point in

1683
01:20:03,610 --> 01:20:06,429
in the stream of responses it gets back

1684
01:20:06,429 --> 01:20:08,949
saying oops your replica you were

1685
01:20:08,949 --> 01:20:11,710
talking to you crashed and so the client

1686
01:20:11,710 --> 01:20:13,480
then knows it has to completely reset up

1687
01:20:13,480 --> 01:20:16,750
everything and so tucked away in in the

1688
01:20:16,750 --> 01:20:20,079
examples are missing event handlers to

1689
01:20:20,079 --> 01:20:21,940
say oh gosh you know we need to go back

1690
01:20:21,940 --> 01:20:24,550
and we establish everything if we get a

1691
01:20:24,550 --> 01:20:26,500
notification that our replicas crashed

1692
01:20:26,500 --> 00:00:00,000
all right I'll continuous

